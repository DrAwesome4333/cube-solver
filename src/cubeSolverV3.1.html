<!DOCTYPE html>
<html>

<head>
	<title>Cube Solver version 3.1</title>
	<style>
		.page {
			position: fixed;
			top: 0vh;
			left: -100vw;
			bottom: 0vh;
			width: 100vw;
			opacity: 0;
			transition: all 0.5s ease-in-out;
			z-index: -2;
			pointer-events: none;
			overflow-y: auto;
		}

		#cube_edit {
			pointer-events: auto;
		}

		.popUp {
			position: absolute;
			top: 25vh;
			left: 25vw;
			width: 50vw;
			height: 50vh;
			background-color: grey;
			z-index: 2;
			opacity: 0;
		}

		canvas {
			position: absolute;
			top: 0px;
			left: 0px;
			width: 100%;
			height: 100%;
			z-index: -1;
			pointer-events: auto;
		}

		.color0 {
			width: 20px;
			height: 20px;
			border-radius: 3px;
			background-color: #0000FF;
			pointer-events: auto;
		}

		.color1 {
			width: 20px;
			height: 20px;
			border-radius: 3px;
			background-color: #E68000;
			pointer-events: auto;
		}

		.color2 {
			width: 20px;
			height: 20px;
			border-radius: 3px;
			background-color: #FFFF00;
			pointer-events: auto;
		}

		.color3 {
			width: 20px;
			height: 20px;
			border-radius: 3px;
			background-color: #FFFFFF;
			pointer-events: auto;
		}

		.color4 {
			width: 20px;
			height: 20px;
			border-radius: 3px;
			background-color: #FF0000;
			pointer-events: auto;
		}

		.color5 {
			width: 20px;
			height: 20px;
			border-radius: 3px;
			background-color: #00FF00;
			pointer-events: auto;
		}

		.colorbg {
			width: 28px;
			height: 28px;
			border-radius: 3px;
			position: absolute;
			top: calc(4vh - 4px);
			left: 9px;
			background-color: #DDD;
			transition: all 0.2s ease-in-out;
			z-index: 2;
		}

		.swatch {
			position: absolute;
			left: 13px;
			transition: all 0.5s ease-in-out;
			cursor: pointer;
			z-index: 3;
			pointer-events: auto;
		}

		input[type=button] {
			color: white;
			font-size: 40px;
			background-color: black;
			border-radius: 10px;
			border: 3px solid white;
			transition: all 0.2s ease-in-out;
			pointer-events: auto;
		}

		input[type=button]:hover {
			color: white;
			background-color: #555555;
			border-radius: 4px;
			border: 3px solid #333333;
		}

		hr {
			color: white;
			size: 2;
			width: 80%;
		}

		.hr1 {
			color: white;
			size: 2;
			width: 80%;
		}

		.hr2 {
			color: white;
			size: 1;
			width: 70%;
		}

		.hr3 {
			color: white;
			size: 1;
			width: 60%;
		}

		h1 {
			font-size: 50px;
			color: white;
		}
	</style>
	<script>
		var pages = [];
		function hidePages(direction, show, ignore) {
			for (var p = 0; p < pages.length; p++) {
				var should_ignore = false;
				for (var i = 0; i < ignore.length && !should_ignore; i++) {
					if (pages[p].id == ignore[i]) {
						should_ignore = true;
					}
				}
				if (!should_ignore) {
					pages[p].style.opacity = 0;
					pages[p].style.left = (direction * 100) + 'vw';
				}
				var should_show = false;
				for (var i = 0; i < show.length && !should_show; i++) {
					if (pages[p].id == show[i]) {
						should_show = true;
					}
				}
				if (should_show) {
					pages[p].style.opacity = 1;
					pages[p].style.left = 0 + 'vw';
				}
			}
		}
		function startPages() {
			pages = document.getElementsByClassName('page');
		}
	</script>
</head>

<body onload="startPages();/*hidePages(1,['loading_screen'],[])*/hidePages(1,['cube_edit','canvas'],[]);start();"
	onresize="">

	<div id="canvas" class="page"></div>
	<div id="loading_screen" class="page">
		<div style="text-align: center;">
			<h1 style="text-align: center;">Cube Solver</h1>
			<br>
			<input type="button" value="Start" onclick="hidePages(-1,['cube_edit','canvas'],[]);">
		</div>
	</div>
	<div id="cube_edit" class="page">
		<div id="side_bar"
			style="width:50px;height:50vh;border-radius:3px;position:absolute;top:25vh;left:-3px;background-color:#323232;transition:all 0.5s ease-in-out;z-index:1;">
			<div class="color0 swatch" style="top: 4vh;"
				onclick="swbg.style.top='calc( 4vh - 4px)';selColor=0;event.stopPropagation();"
				ontouchstart="this.dispatchEvent(new MouseEvent('click'));event.stopPropagation();"></div>
			<div class="color1 swatch" style="top:12vh;"
				onclick="swbg.style.top='calc(12vh - 4px)';selColor=1;event.stopPropagation();"
				ontouchstart="this.dispatchEvent(new MouseEvent('click'));event.stopPropagation();"></div>
			<div class="color2 swatch" style="top:20vh;"
				onclick="swbg.style.top='calc(20vh - 4px)';selColor=2;event.stopPropagation();"
				ontouchstart="this.dispatchEvent(new MouseEvent('click'));event.stopPropagation();"></div>
			<div class="color3 swatch" style="top:28vh;"
				onclick="swbg.style.top='calc(28vh - 4px)';selColor=3;event.stopPropagation();"
				ontouchstart="this.dispatchEvent(new MouseEvent('click'));event.stopPropagation();"></div>
			<div class="color4 swatch" style="top:36vh;"
				onclick="swbg.style.top='calc(36vh - 4px)';selColor=4;event.stopPropagation();"
				ontouchstart="this.dispatchEvent(new MouseEvent('click'));event.stopPropagation();"></div>
			<div class="color5 swatch" style="top:44vh;"
				onclick="swbg.style.top='calc(44vh - 4px)';selColor=5;event.stopPropagation();"
				ontouchstart="this.dispatchEvent(new MouseEvent('click'));event.stopPropagation();"></div>
			<div class="colorbg" id="swbg"></div>
		</div>
		<input type="button" value="Options" onclick="hidePages(1,['options'],['canvas'])"
			style="position:absolute;bottom:0vh;left:0vh;" ontouchstart="this.dispatchEvent(new MouseEvent('click'));">
		<input type="button" value="Solve"
			onclick="/*mode=1;hidePages(-1,['cube_solve'],['canvas'])*/Solver.SolveCube(testCube.data,0,testCube.size,undefined,undefined,testCube);event.stopPropagation();"
			ontouchstart="this.dispatchEvent(new MouseEvent('click'));" style="position:absolute;bottom:0vh;right:0vh;">
		<input type="button" value="i" style="position:absolute;top:0vh;right:0vh;"
			ontouchstart="this.dispatchEvent(new MouseEvent('click'));">
		<div id="debugOP" style="position:absolute;bottom:0px;left:20vh;color:white;"></div>
	</div>

	<div id="cube_solve" class="page">
		<h1 style="color:white;font-size:50px;text-align:center;">Solving...</h1>
		<input type="button" value="Cancel" style="position:absolute;bottom:10vh;width:30vw;left:35vw;"
			onclick="mode=0;hidePages(1,['cube_edit'],['canvas']);">
	</div>

	<div id="options" class="page" style="background-color:rgba(0,0,0,0.75);pointer-events:auto;">
		<input value="Back" type="button" style="position:absolute;top:0px;right:0px;"
			onclick="hidePages(-1,['cube_edit'],['canvas'])">
		<br><br>
		<blockquote>
			<blockquote>
				<h1>Options</h1>
				<hr class="hr1">
				<br>
				<blockquote>
					<h1>Cube</h1>
				</blockquote>
				<hr class="hr2">
			</blockquote>
		</blockquote>
	</div>
	<script>
		var mainVertexSource = "\
		    uniform mat4 world_matrix;\n\
		    uniform mat4 model_matrix;\n\
			uniform mat3 normal_matrix;\n\
		    uniform mat4 perspective_matrix;\n\
		    uniform vec3 light_direction;\n\
			uniform vec3 camera_position;\n\
		    attribute vec3 point;\n\
		    attribute vec3 color;\n\
			attribute vec3 normal;\n\
			attribute vec3 u_bitangent;\n\
			attribute vec3 v_bitangent;\n\
		    attribute vec2 main_uv;\n\
		    attribute vec2 normal_uv;\n\
		    varying vec3 iColor;\n\
		    varying vec2 iMain_uv;\n\
		    varying vec2 iNormal_uv;\n\
			varying vec3 _light_direction;\n\
			varying vec3 _camera_position;\n\
			varying vec3 fragment_position;\n\
			vec3 iNormal;\n\
			vec3 iUT;\n\
			vec3 iVT;\n\
			mat3 world_to_tangent;\n\
		    void main(void){\n\
				iNormal = normal_matrix * normal;\n\
				iUT = normal_matrix * u_bitangent;\n\
				iVT = normal_matrix * v_bitangent;\n\
				world_to_tangent[0][0] = iUT.x;\n\
				world_to_tangent[0][1] = iVT.x;\n\
				world_to_tangent[0][2] = iNormal.x;\n\
				world_to_tangent[1][0] = iUT.y;\n\
				world_to_tangent[1][1] = iVT.y;\n\
				world_to_tangent[1][2] = iNormal.y;\n\
				world_to_tangent[2][0] = iUT.z;\n\
				world_to_tangent[2][1] = iVT.z;\n\
				world_to_tangent[2][2] = iNormal.z;\n\
		        iColor = color;\n\
		        iMain_uv = main_uv;\n\
		        iNormal_uv = normal_uv;\n\
				_light_direction = world_to_tangent * -light_direction;\n\
				_camera_position = world_to_tangent * camera_position;\n\
				fragment_position = world_to_tangent * (world_matrix * model_matrix * vec4(point,1.0)).xyz;\n\
		        gl_Position = perspective_matrix * world_matrix * model_matrix * vec4(point,1.0);\n\
		    }\n\
		    ";
		/*
		main_texture:-1,
	bump_texture:-1,
	back_color:-1,
	light_direction:-1,
	overlay_color:-1,
	world_matrix:-1,
	model_matrix:-1,
	perspective_matrix:-1,
	texture_mode:-1
    
	point:-1,
	color:-1,
	normal:-1,
	main_uv:-1,
	bump_uv:-1
		*/
		var mainFragmentSource = "\
		    precision highp float;\n\
		    uniform sampler2D main_texture;\n\
		    uniform sampler2D bump_texture;\n\
		    uniform int texture_mode;\n\
		    uniform vec3 back_color;\n\
		    uniform vec3 overlay_color;\n\
			uniform bool backLight;\n\
		    varying vec3 iColor;\n\
			vec3 iNormal;\n\
			vec3 surfaceToEye;\n\
			vec3 halfV;\n\
		    varying vec2 iMain_uv;\n\
		    varying vec2 iNormal_uv;\n\
			varying vec3 _light_direction;\n\
			varying vec3 _camera_position;\n\
			varying vec3 fragment_position;\n\
		    void main(void){\n\
				iNormal = texture2D(bump_texture,iNormal_uv).rgb * 2.0-1.0;\n\
				surfaceToEye = normalize(_camera_position-fragment_position);\n\
				halfV = normalize(normalize(_light_direction)+surfaceToEye);\n\
				float spec = max(pow(dot(iNormal,halfV),1000.0),0.0);\n\
		        vec4 data = texture2D(main_texture,iMain_uv);\n\
				float light_level = max(dot( normalize( _light_direction ) , normalize( iNormal ) ),0.0);\n\
				if(light_level==0.0){\n\
					spec = 0.0;\n\
				}\n\
				if(backLight){////turn off lighting for piece\n\
					spec=0.0;\n\
					light_level=1.0;\n\
				}\n\
		        if(texture_mode == 0){\n\
		            gl_FragColor = vec4(mix(iColor,back_color,data.r)*overlay_color*max(light_level,0.4),1.0);\n\
					gl_FragColor.rgb += spec;\n\
		        }else if(texture_mode == 2){\n\
					data.a=1.0;\n\
		            gl_FragColor = data;\n\
		        }\n\
				else{\n\
		            gl_FragColor = vec4(back_color * light_level,1.0);\n\
		        }\n\
		    }\n\
		     ";
		var mainVertexShader = null;
		var mainFragmentShader = null;
		var debugFragmentSource = "\
		    precision highp float;\n\
		    uniform sampler2D main_texture;\n\
		    varying vec2 _uv;\n\
		    void main(void){\n\
		      gl_FragColor = texture2D(main_texture,_uv);\n\
		    }\n\
		     ";
		var debugVertexSource = "\
		    attribute vec2 point;\n\
			attribute vec2 uv;\n\
		    varying vec2 _uv;\n\
		    void main(void){\n\
			_uv = uv;\n\
		        gl_Position = vec4(point,-1.0,1.0);\n\
		    }\n\
		    ";
		var mapVertexShader = null;
		var mapFragmentShader = null;

		var mapFragmentSource = "\
		    precision highp float;\n\
		    varying vec3 iColor;\n\
		    void main(void){\n\
		      gl_FragColor = vec4(iColor.rgb,1.0);\n\
		    }\n\
		     ";
		var mapVertexSource = "\
		    uniform mat4 world_matrix;\n\
		    uniform mat4 model_matrix;\n\
		    uniform mat4 perspective_matrix;\n\
		    attribute vec3 point;\n\
		    attribute vec3 id_color;\n\
		    varying vec3 iColor;\n\
		    void main(void){\n\
		        iColor = id_color;\n\
		        gl_Position = perspective_matrix * world_matrix * model_matrix * vec4(point,1.0);\n\
		    }\n\
		    ";

		var debugVertexShader = null;
		var debugFragmentShader = null;
	</script>
	<script>
		var gl = null;//A global refrence to Renderer.gl so that I don't have to keep typing Renderer.gl or this.gl, just gl.			
		const PR = Math.PI / 180;//(Pi ratio, use this to convert degrees to Radians)

		var CubieType = {
			Center: 0,
			Edge: 1,
			Corner: 2
		};
		var CubieStyle = {
			Plain: 0,
			Fast: 1
		};
		var CubeType = {
			Real: 0,//data changes when cube is rotated, used for a manual solve, uses piece or surface data
			Edit: 1,//easily edited by user, uses surface type cube data. 
			Solve: 2//used for demonstrating solves, keeps a starting state and goes through the movements without changing cube data. Uses piece data or surface data
		};
		var CubeDataType = {
			Surface: 0,
			Piece: 1,
			Compact: 2,
			Fast: 3
		};


		function Cubie(type, style, data) {
			this.type = type;// 0 1 or 2 for center, edge or corner
			this.style = style;// selects a model type to get
			this.home = 0;// lets the code know which surface is defined as the "home" surface, to make coloring easier.
			this.dataLink = [0, 0, 0];//a list of numbers stored in the cubie by the cube so it can recognize what data this cubie is linked to.
			this.model = Renderer.GetModel(style, type, data);
			this.highlightedSides = [false, false, false, false];//used for hovering and error highlights
			this.inError = false;
			this.errorMessage = "";
			//model format [VBO, IBO1(side 1), IBO2(side 2), IBO3(side 3), IBO4(back model) ,matrix, style, type, index count1 (ic), ic2, ic3, ic4, tempMatrix(used for temporary transforms such as turns before they get permanately added)]
			//new model format [VBO, IBO(pointer), faceLocations, matrix, style, type, tempMatrix]
			var nBuffer = gl.createBuffer();
			gl.bindBuffer(gl.ARRAY_BUFFER, nBuffer);
			gl.bufferData(gl.ARRAY_BUFFER, this.model[0], gl.STATIC_DRAW);
			this.model[0] = nBuffer;
		}
		/*
		Cube data always starts with the left most information, then bottom most, and then back most. (smaller to biggest) (with the excpetion of model files)
		There are a few formats a Cube can be save in:
		Surface: an array filled with the information about each sticker of the cube, each sticker takes up 3 bits. Used for the editable cubes, 
		Piece: an array filled with the information about each location and the piece that fills it, each location takes up 5 bits. Used for solving and animating cubes
		Compact: An array filled with information about each corner location, no orientation or other pieces are saved, this loses a lot of information. Used for quick testing and creating,
		 should only be used when speed and memory are required and actual cube information is not, helps lower the number of cubes needed to actualy test a solve on.
		Fast: An array were each item in the array contains a sticker simmilar to Surface type but not compressed, it does not need to deal with bits to work so it does not need a lot of
			Utility functions, Cubes can take up a lot of space.
		All cubes are stored with a Uint8 Array for memory reasons. Several cubes can be saved in one, must be cubes of the same size and format for best results.
		*/

		/*
		Format information
		Surface: Bits per Cube: 18 * size^2;
		Piece: Bits per Cube: 5 * (size^3 - (size-2)^3);
		Compact: Bits per Cube: 24 Bytes: 3
		
		*/


		var solved = [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 2, 3, 2, 3, 2, 3, 4, 4, 4, 1, 1, 1, 2, 3, 2, 3, 2, 3, 4, 4, 4, 1, 1, 1, 2, 3, 2, 3, 2, 3, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5];

		function generateSolvedCube(size = 3, type = 0) {
			aCube = CubeData.Create(CubeDataType.Surface, size, 1);
			var index = 0;
			for (var i = 0; i < size * size; i++) {//left side
				CubeData.Change(aCube, CubeDataType.Surface, 0, i, size, 0);
			}
			index += size * size;

			for (var i = 0; i < size; i++) {//middle sides
				for (var j = 0; j < size; j++) {//bottom side
					CubeData.Change(aCube, CubeDataType.Surface, 0, index + j, size, 1);
				}
				index += size;
				for (var j = 0; j < size; j++) {//back side
					CubeData.Change(aCube, CubeDataType.Surface, 0, index + j * 2, size, 2);
				}
				for (var j = 0; j < size; j++) {//front side
					CubeData.Change(aCube, CubeDataType.Surface, 0, index + j * 2 + 1, size, 3);
				}
				index += 2 * size;
				for (var j = 0; j < size; j++) {//top side
					CubeData.Change(aCube, CubeDataType.Surface, 0, index + j, size, 4);
				}
				index += size;
			}


			for (var i = 0; i < size * size; i++) {//right side
				CubeData.Change(aCube, CubeDataType.Surface, 0, i + index, size, 5);
			}
			var bCube = aCube;
			if (type != CubeDataType.Surface) {
				bCube = CubeData.Convert(aCube, CubeDataType.Surface, type, size, true);
			}
			return bCube;
		}
		var CubeData = {
			Create: function (format = 0, size = 3, count = 1) {
				/*
				This method wil return a empty Uint8 Array that can hold the specified format of cube for a particular size. Count is how many cubes should be in this array		
				*/
				if (format == CubeDataType.Surface) {
					var newArray = new Uint8Array(Math.ceil(count * (size * size * 18) / 8));


					return newArray;
				} else if (format == CubeDataType.Piece) {
					var newArray = new Uint8Array(Math.ceil(count * ((size * size * size - (size - 2) * (size - 2) * (size - 2)) * 5) / 8));

					return newArray;
				} else if (format == CubeDataType.Compact) {
					var newArray = new Uint8Array(3);

					return newArray;
				} else if (format == CubeDataType.Fast) {
					var newArray = new Uint8Array(count * (size * size * 6));

					return newArray;
				}
				return new Unit8Array(0);

			},
			Convert: function (data, format1 = 0, format2 = 0, size = 3, canError = false) {
				/*
				Creates a new Uint8 Array in format2 that holds the same cubes as data which is in format1
				If an attempt is made to convert from a compact cube to a piece or surface cube, an empty array is returned.
				Uses size to determine the sizes of cubes in the data.
				canError is used to tell if the function should continue to find more errors after one is found and report them
				Error Types: Invalid Piece: Too many of one color is on this piece,  Invalid Piece: this piece does not exist on the cube (Check centers and make sure they match your cubes's), 
				Invalid Conversion: Cannot convert to Surface (or Piece) from compact
				Invalid Pieces: to many of one piece was found.
				*/
				var errors = [];//errors show up in 4 parts "String describing error", pieceToHighlightRed,SideToHighLightRed (4 for whole piece)
				switch (format1) {
					case CubeDataType.Surface: {
						switch (format2) {
							case CubeDataType.Surface: {
								return CubeData.Copy(data);
								break;
							}
							case CubeDataType.Piece: {
								//this conversion is accomplished by basically going through each 'block' or cubie (including not visible sections) in LDB order and seeing
								//what surfaces or stickers are in contact with that location. This list is then read as a piece by matching it up with the piece codes and home orientation
								//
								var count = Math.floor(data.length / ((size * size * 18) / 8));
								var newData = CubeData.Create(CubeDataType.Piece, size, count);
								var PS = CubeData.GetPartString(size);
								var CenterCount = 0;
								var EdgeCount = 0;
								var CornerCount = 0;
								var pieceCount = 0;
								var sides = CubeData.GetSides(0, 0, 0, size);
								var colors = [0, 0, 0];
								var x = 0, y = 0, z = 0;
								var max = size - 1;
								var hitEnd = false;
								function advance() {
									z++;
									if (z > max) {
										y++;
										z = 0;
										if (y > max) {
											x++;
											y = 0;
											if (x > max) {
												x = max;
												hitEnd = true;
											}
										}
									}
									sides = CubeData.GetSides(x, y, z, size);
								}
								for (var i = 0; i < PS.length; i++) {
									while (sides.length == 0 && !hitEnd) {
										advance();
									}

									if (sides.length == 1) {
										colors[0] = CubeData.PullSide(data, CubeDataType.Surface, size, 0, sides[0]);
										CubeData.Change(newData, CubeDataType.Piece, 0, i, size, colors[0]);
									}
									if (sides.length == 2) {
										colors[0] = CubeData.PullSide(data, CubeDataType.Surface, size, 0, sides[0]);
										colors[1] = CubeData.PullSide(data, CubeDataType.Surface, size, 0, sides[1]);
										var code = CubeData.ColorsToPiece([colors[0], colors[1]], x, y, z);
										if (code == 255) {
											if (canError) {
												errors.push("This edge can't exist", i, 4);
											} else {
												throw "Error converting cube from surface to piece: Non existant edge";
											}
										}
										CubeData.Change(newData, CubeDataType.Piece, 0, i, size, code);
									}
									if (sides.length == 3) {
										colors[0] = CubeData.PullSide(data, CubeDataType.Surface, size, 0, sides[0]);
										colors[1] = CubeData.PullSide(data, CubeDataType.Surface, size, 0, sides[1]);
										colors[2] = CubeData.PullSide(data, CubeDataType.Surface, size, 0, sides[2]);
										var code = CubeData.ColorsToPiece(colors, x, y, z);
										if (code == 255) {
											if (canError) {
												errors.push("This corner can't exist", i, 4);
											} else {
												throw "Error converting cube from surface to piece: Non existant corner";
											}
										}
										CubeData.Change(newData, CubeDataType.Piece, 0, i, size, code);
									}
									advance();

								}
								if (errors.length > 0) {
									console.log(errors);
								}
								if (canError)
									return [newData, errors];

								return newData;
							}
							case CubeDataType.Compact: {
								var count = Math.floor(data.length / ((size * size * 18) / 8));
								var newData = new Uint8Array(3 * count);
								var sides = CubeData.GetSides(0, 0, 0, size);
								var colors = [0, 0, 0];
								var x = 0, y = 0, z = 0;
								var max = size - 1;
								var hitEnd = false;
								function advance() {
									z += max;
									if (z > max) {
										y += max;
										z = 0;
										if (y > max) {
											x += max;
											y = 0;
											if (x > max) {
												x = max;
												hitEnd = true;
											}
										}
									}
									sides = CubeData.GetSides(x, y, z, size);
								}
								for (var i = 0; i < 8 && !hitEnd; i++) {

									if (sides.length == 3) {
										colors[0] = CubeData.PullSide(data, CubeDataType.Surface, size, 0, sides[0]);
										colors[1] = CubeData.PullSide(data, CubeDataType.Surface, size, 0, sides[1]);
										colors[2] = CubeData.PullSide(data, CubeDataType.Surface, size, 0, sides[2]);
										var code = CubeData.ColorsToPiece(colors, x, y, z);
										if (code == 255) {
											if (canError) {
												errors.push("This corner can't exist", i, 4);
											} else {
												throw "Error converting cube from surface to piece: Non existant corner";
											}
										}
										CubeData.Change(newData, CubeDataType.Compact, 0, i, size, code % 8);
									}
									advance();

								}
								if (errors.length > 0) {
									console.log(errors);
								}
								if (canError)
									return [newData, errors];

								return newData;
							}
							case (CubeDataType.Fast): {
								var newData = CubeData.Create(CubeDataType.Fast, size);
								for (var i = 0; i < newData.length; i++) {
									newData[i] = CubeData.PullSide(data, format1, size, cube, i);
								}
								return newData;
							}
						}
					}
					case CubeDataType.Piece: {
						switch (format2) {
							case CubeDataType.Surface: {
								var count = Math.floor((data.length * 8) / (((size * size * size) - ((size - 2) * (size - 2) * (size - 2))) * 5));
								var newData = CubeData.Create(CubeDataType.Surface, size, count);
								for (var i = 0; i < count * size * size * 6; i++) {
									CubeData.Change(newData, CubeDataType.Surface, Math.floor(i / (size * size * 6)), i % (size * size * 6), size, CubeData.PullSide(data, CubeDataType.Piece, size, Math.floor(i / (size * size * 6)), i % (size * size * 6)));
								}
								return newData;
								break;
							}
							case CubeDataType.Piece: {
								return CubeData.Copy(data);
							}
							case CubeDataType.Compact: {
								var count = Math.floor(data.length / (((size * size * size) - ((size - 2) * (size - 2) * (size - 2))) * 5));
								var newData = new Uint8Array(3 * count);
								for (var cube = 0; cube < count; cube++) {
									CubeData.Change(newData, CubeDataType.Compact, cube, 0, size, CubeData.PullInfo(data, 0, 5) % 8);
									CubeData.Change(newData, CubeDataType.Compact, cube, 1, size, CubeData.PullInfo(data, 2, 5) % 8);
									CubeData.Change(newData, CubeDataType.Compact, cube, 2, size, CubeData.PullInfo(data, 6, 5) % 8);
									CubeData.Change(newData, CubeDataType.Compact, cube, 3, size, CubeData.PullInfo(data, 8, 5) % 8);
									CubeData.Change(newData, CubeDataType.Compact, cube, 4, size, CubeData.PullInfo(data, 17, 5) % 8);
									CubeData.Change(newData, CubeDataType.Compact, cube, 5, size, CubeData.PullInfo(data, 19, 5) % 8);
									CubeData.Change(newData, CubeDataType.Compact, cube, 6, size, CubeData.PullInfo(data, 24, 5) % 8);
									CubeData.Change(newData, CubeDataType.Compact, cube, 7, size, CubeData.PullInfo(data, 26, 5) % 8);

								}
								return newData;
							}
							case (CubeDataType.Fast): {
								var newData = CubeData.Create(CubeDataType.Fast, size);
								for (var i = 0; i < newData.length; i++) {
									newData[i] = CubeData.PullSide(data, format1, size, cube, i);
								}
								return newData;
							}
						}
					}
					case CubeDataType.Compact: {
						return null;//There are no conversions for compact data, too much info is lost on compaction.
					}
					case CubeDataType.Fast: {
						switch (format2) {
							case (CubeDataType.Surface): {
								var newData = CubeData.Create(CubeDataType.Surface, size);
								for (var i = 0; i < data.length; i++) {
									CubeData.Change(newData, CubeDataType.Surface, 0, i, size, data[i]);
								}
								return newData;
							}
							case (CubeDataType.Piece): {
								var newData = CubeData.Convert(data, CubeDataType.Fast, CubeDataType.Surface, size);//So we convert it to a surface type cube, which is simple enough for this.
								var nData = CubeData.Convert(newData, CubeDataType.Surface, format2, size, canError);//Why rewrite what has been written?
								return nData;

							}
						}
					}
				}
			},
			ColorsToPiece: function (colors = [0, 1, 2], x = 0, y = 0, z = 0) {
				//this will take a list of colors and the location of a piece to determin what piece code this should be. If it is invalid, value 255 is returned
				//This is accomplished by first testing if the given location is in Clockwise or Counter Clockwise order when given in LDB order. Once that is done
				//a comparison is done with cube piece codes to see if it matches any of the codes. Different home values are tested to find the right number.
				if (colors.length == 1) {
					return colors[0];
				}
				if (colors.length == 2) {
					var home = 0;
					for (; home < 2; home++) {
						for (var i = 8; i < 20; i++) {// 8 in pieceCodes is where the edge codes start
							if (colors[home].toString() == CubeData.PieceCodes[i][0] && colors[(home + 1) % 2].toString() == CubeData.PieceCodes[i][1]) {
								return (i - 8) + (home * 12);
							}
						}
					}
					return 255;
				}
				if (colors.length == 3) {
					var home = 0;
					var cw = true;
					if ((x == 0 && y == 0 && z != 0) || (x == 0 && y != 0 && z != 0) || (x != 0 && y != 0 && z == 0) || (x != 0 && y == 0 && z == 0)) {//finds the pieces where the data is not already clockwise when given through color[]
						cw = false;
					}
					for (; home < 3; home++) {
						for (var i = 0; i < 8; i++) {
							if (cw) {
								if (colors[home].toString() == CubeData.PieceCodes[i][0] && colors[(home + 1) % 3].toString() == CubeData.PieceCodes[i][1] && colors[(home + 2) % 3].toString() == CubeData.PieceCodes[i][2]) {
									return i + (home * 8);
								}
							} else {
								if (colors[home].toString() == CubeData.PieceCodes[i][0] && colors[(home + 2) % 3].toString() == CubeData.PieceCodes[i][1] && colors[(home + 1) % 3].toString() == CubeData.PieceCodes[i][2]) {
									return i + (home * 8);
								}
							}
						}
					}
					return 255;
				}
				return 255;
			},
			Change: function (data, format = 0, cube = 0, index = 0, size = 3, information = 0) {
				/*
				This will change the cube in data at cube# cube in the specified format and change the data index and replace it with the new information
				This changes the original data.
				Index for surface means the surface / sticker number
				Index for Pice means the part / piece number
				Index for compact means the corner number
				
				Information must be a valid id for a piece/color
				*/

				switch (format) {
					case CubeDataType.Surface: {
						var cubeOffset = cube * (size * size * 6 * 3); //measured in bits (3 bits per sticker to identify color)
						var dataOffset = cubeOffset + index * 3;
						CubeData.ChangeBinaryData(data, dataOffset, information, 3);
						break;
					}
					case CubeDataType.Piece: {
						var cubeOffset = cube * ((size * size * size - (size - 2) * (size - 2) * (size - 2)) * 5); //measured in bits (5 bits per bit)
						var dataOffset = cubeOffset + index * 5;
						CubeData.ChangeBinaryData(data, dataOffset, information, 5);
						break;
					}
					case CubeDataType.Compact: {
						var cubeOffset = cube * 24; //measured in bits
						var dataOffset = cubeOffset + index * 3;
						CubeData.ChangeBinaryData(data, dataOffset, information, 3);
						break;
					}
					case CubeDataType.Fast: {
						var cubeSize = size * size * 6;
						data[cube * cubeSize + index] = information;
					}
				}
			},
			Copy: function (data) {
				/*
					copies the data into a new Uint8 array.
				*/
				var returnArray = new Uint8Array(data.length);
				returnArray.set(data);
				return returnArray;
			},
			PullCube: function (data, format = 0, cube = 0, size = 3) {
				/*
					gets a cube out of a larger array of cubes and puts it into its own array
					Data: the information to pull the cube from
					Format: the format type of the data and the output cube
					Cube: cube number to pull from the data
					Size: the base dimension of the cube (3 for a 3 X 3, 4 for a 4 by 4)
					TODO : Make it more efficient, It can be done by finding how many full bytes there are.
				*/
				switch (format) {
					case CubeDataType.Surface: {
						var newData = CubeData.Create(CubeDataType.Surface, size, 1);
						var cubeSize = size * size * 6;
						for (var i = 0; i < cubeSize; i++) {
							CubeData.Change(newData, CubeDataType.Surface, 0, i, size, CubeData.PullInfo(data, cube * cubeSize + i, 3));
						}
						/*var segments = 1;
						while(cubeSize*3/segments>32){
							segments++;
						}
						for(var i = 0;i<segments;i++){
							CubeData.ChangeBinaryData(newData,0,);
						}*/

						return newData;
					}
					case CubeDataType.Piece: {
						var newData = CubeData.Create(CubeDataType.Piece, size, 1);
						var cubeSize = (size * size * size - (size - 2) * (size - 2) * (size - 2))
						for (var i = 0; i < cubeSize; i++) {
							CubeData.Change(newData, CubeDataType.Piece, 0, i, size, CubeData.PullInfo(data, cube * cubeSize * 5 + i, 5));
						}

						return newData;
					}
					case CubeDataType.Compact: {
						var newData = CubeData.Create(CubeDataType.Compact, size, 1);
						for (var i = 0; i < 8; i++) {
							CubeData.Change(newData, CubeDataType.Compact, 0, i, size, CubeData.PullInfo(data, cube * 24 + i, 3));
						}

						return newData;
					}
					case CubeDataType.Fast: {
						var cubeSize = size * size * 6;
						var newData = CubeData.Create(CubeDataType.Fast, size, 1);
						for (var i = 0; i < cubeSize; i++) {
							newData[i] = data[i + cubeSize * cube];
						}
						return newData;
					}
				}
			},
			PasteCube: function (data, format = 0, cubeData, cubeIndex = 0, size = 3) {
				/*
				takes the cubeData and inserts it into  an array(data)
				Data: the information to paste the cube into
				Format: the format type of the data, must match  that of cubeData.
				CubeData: the information about the cube to be pasted
				CubeIndex: the cube index to paste the data into (will over write existing data if there is any present)
				Size: the base dimention of the cube
				TODO
				*/
				var newData;
				switch (format) {
					case CubeDataType.Surface: {
						var cubeSize = size * size * 6;
						for (var i = 0; i < cubeSize; i++) {
							CubeData.Change(data, CubeDataType.Surface, cubeIndex, i, size, CubeData.PullInfo(cubeData, i, 3));
						}

						return data;
					}
					case CubeDataType.Piece: {
						var cubeSize = (size * size * size - (size - 2) * (size - 2) * (size - 2));
						for (var i = 0; i < cubeSize; i++) {
							CubeData.Change(data, CubeDataType.Piece, cubeIndex, i, size, CubeData.PullInfo(cubeData, i, 5));
						}

						return data;
					}
					case CubeDataType.Surface: {
						for (var i = 0; i < 8; i++) {
							CubeData.Change(data, CubeDataType.Compact, cubeIndex, i, size, CubeData.PullInfo(cubeData, i, 3));
						}

						return data;
					}
					case CubeDataType.Fast: {
						var cubeSize = size * size * 6;
						for (var i = 0; i < cubeData.length; i++) {
							data[i + cubeSize * cube] = cubeData[i];
						}
					}
				}

			},
			ConvertToBinaryString: function (data = 0, length = 1) {
				/*
					converts a number into a string of 1 and 0 at the desired length (may be bigger if value found is very large.)
					Uses big-edian as that is what .toString does.
					REMOVE ?
				*/
				var returnString = data.toString(2);
				while (returnString.length < length) {
					returnString = "0" + returnString;
				}
				return returnString;
			},
			PullSide: function (data, format = 0, size = 3, cube = 0, number = 0) {
				var rInfo = 0;
				if (format == CubeDataType.Surface) {
					rInfo = CubeData.PullInfo(data, cube * (size * size * 6) + number, 3);//Stickers / sides are already in a format that can easily be pulled
				} else if (format == CubeDataType.Fast) {
					rInfo = data[cube * (size * size * 6) + number];//Stickers / sides are already in a format that can easily be pulled
				} else if (format == CubeDataType.Piece) {
					//TODO
					//NEEDS MORE TESTING
					var x = 0, y = 0, z = 0;
					var offSet = 0;
					var face = 0;// left, bottom, back, front, top, right
					if (number < size * size) {// on left face
						x = 0;
						y = Math.floor(number / size);
						z = number % size;
						face = 0;

					} else if (number < size * size + (4 * size) * size) {//center parts of cube
						x = Math.floor((number - size * size) / (4 * size));
						offSet = x * 4 * size + size * size;
						if (number - offSet < size) {//On bottom face
							y = 0;
							z = number - offSet;
							face = 1;
						} else if (number - offSet < size * 3) {//on front or back face
							y = Math.floor((number - (offSet + size)) / 2);
							if (y < (number - (offSet + size)) / 2) {
								z = size - 1;
								face = 3;
							} else {
								z = 0;
								face = 2;
							}
						} else {// on top face
							y = size - 1;
							z = number - (offSet + size * 3);
							face = 4;
						}

					} else {//on right face
						x = size - 1;
						offSet = size * size + size * size * 4;
						y = Math.floor((number - offSet) / size);
						z = (number - offSet) % size;
						face = 5;
					}

					var pieceNumber = 0;
					offSet = 0;
					if (x == 0) {//on left layer
						pieceNumber = y * size + z;
					} else if (x < size - 1) {//middle sections
						if (y == 0) {//bottom layer
							offSet = size * size + (x - 1) * (size * size - (size - 2) * (size - 2));
							pieceNumber = offSet + z;
						} else if (y < size - 1) {//middle layers
							offSet = size * size + (x - 1) * (size * size - (size - 2) * (size - 2));
							if (z == 0) { // backlayer
								pieceNumber = offSet + size + ((y - 1) * 2);
							} else {
								pieceNumber = offSet + size + ((y - 1) * 2) + 1;//front layer, any other layer should not show up
							}
						} else {//top layer
							offSet = size * size + (x - 1) * (size * size - (size - 2) * (size - 2)) + size + 2 * (size - 2);
							pieceNumber = offSet + z;
						}
					} else {
						offSet = size * size + (size - 2) * (size * 2 + (size - 2) * 2);
						pieceNumber = offSet + y * size + z;
					}

					var pieceId = CubeData.PullInfo(data, pieceNumber + (cube * ((size * size * size) - ((size - 2) * (size - 2) * (size - 2)))), 5);
					var sides = CubeData.CountSides(x, y, z, size);
					if (sides == 1) {
						rInfo = pieceId;//see if it is a center
					} else if (sides == 2) {
						var locationFaces = CubeData.GetFaces(x, y, z, size);

						var surfaceIndex = 0;

						for (var i = 0; i < 2; i++) {
							if (locationFaces[i] == face) {
								surfaceIndex = i;
							}
						}
						var pieceHome = Math.floor(pieceId / 12);

						rInfo = parseInt(CubeData.PieceCodes[pieceId % 12 + 8][(pieceHome + surfaceIndex) % 2]);
					} else if (sides == 3) {
						var locationFaces = CubeData.GetFaces(x, y, z, size);
						var cw = true;
						if ((x == 0 && y == 0 && z != 0) || (x == 0 && y != 0 && z != 0) || (x != 0 && y != 0 && z == 0) || (x != 0 && y == 0 && z == 0)) {//finds the pieces where the data is not already clockwise when given through color[]
							cw = false;
						}

						var surfaceIndex = 0;

						for (var i = 0; i < 3; i++) {
							if (cw && locationFaces[i] == face) {
								surfaceIndex = i;
								break;
							} else if (!cw) {
								if (locationFaces[i] == face && i == 0)
									surfaceIndex = 0;
								if (locationFaces[i] == face && i == 2)
									surfaceIndex = 1;
								if (locationFaces[i] == face && i == 1)
									surfaceIndex = 2;
							}
						}
						var pieceHome = Math.floor(pieceId / 8);

						rInfo = parseInt(CubeData.PieceCodes[pieceId % 8][(pieceHome + surfaceIndex) % 3]);
					}


				} else {
					return 255;//compact cubes are not supported here.
				}

				return rInfo;
			},
			PullInfo: function (data, index, infoSize) {
				/*
					Will pull a binary number from some data of the specified size at the specified index.
				*/
				var startBit = index * infoSize;
				var byteStart = Math.floor(startBit / 8);//find the first and last bytes  that will be searched
				var byteEnd = Math.floor((startBit + infoSize) / 8);

				var offSet = startBit % 8;
				var returnInfo = 0;
				var bitSizedData;
				var byte = byteStart;
				for (var i = 0; i < infoSize; i++) {
					bitSizedData = (data[byte] >> (8 - offSet - 1)) % 2;//shift the bit we want all the way to the right, and then remove higher bits.
					returnInfo <<= 1;
					returnInfo += bitSizedData;
					offSet++;
					if (offSet >= 8) {
						byte++;
						offSet %= 8;
						if (byte > byteEnd)//make sure we don't crash due to stupid mistakes
							break;
					}

				}
				return returnInfo;
			},
			ChangeBinaryData: function (data, index, info, infoLength) {
				/*This function will efficiently update binary data
				starting at the index (in bits)(data must be type Uint8Array)
				data is the data being worked on
				info is the replacement data (a number)
				infoLength defines the number of binary digits, helps find 0's at the begining of smaller numbers.
				*/
				var byteStart = Math.floor(index / 8);//find the first and last bytes  that will be updated
				var byteEnd = Math.floor((index + infoLength) / 8);

				var offSet = index % 8;
				var bitSizedData = 0;
				var bitSizedInfo = 0;
				var byte = byteStart;
				for (var i = 0; i < infoLength; i++) {
					bitSizedData = (data[byte] >> (8 - offSet - 1)) % 2;//shift the bit we want all the way to the right, and then remove higher bits.
					bitSizedInfo = (info >> (infoLength - i - 1)) % 2;

					if (bitSizedData != bitSizedInfo) {//check if the bits match, if they don't change them throuh addition or subtraction.
						if (bitSizedInfo == 1)
							data[byte] += Math.pow(2, (8 - offSet - 1));
						else
							data[byte] -= Math.pow(2, (8 - offSet - 1));
					}
					offSet++;
					if (offSet >= 8) {
						byte++;
						offSet %= 8;
						if (byte > byteEnd)//make sure we don't crash due to stupid mistakes
							break;
					}

				}


			},
			GetSides: function (x, y, z, size) {
				//Returns the stickers a certain piece coordinate (starting with 0) colides with, starting with the LDB piece
				var max = size - 1;
				var sides = [];
				if (x == 0)
					sides.push(y * size + z);
				if (y == 0)
					sides.push(size * size + x * 4 * size + z);
				if (z == 0)
					sides.push(size * size + x * 4 * size + y * 2 + size);
				if (z == max)
					sides.push(size * size + x * 4 * size + y * 2 + size + 1);
				if (y == max)
					sides.push(size * size + x * 4 * size + z + 3 * size);
				if (x == max)
					sides.push(y * size + z + size * size + size * 4 * size);
				return sides;

			},
			GetFaces: function (x, y, z, size) {
				//Returns the facesa certain piece coordinate (starting with 0) colides with, starting with the LDB piece
				var max = size - 1;
				var sides = [];
				if (x == 0)
					sides.push(0);
				if (y == 0)
					sides.push(1);
				if (z == 0)
					sides.push(2);
				if (z == max)
					sides.push(3);
				if (y == max)
					sides.push(4);
				if (x == max)
					sides.push(5);
				return sides;

			},
			CountSides: function (x, y, z, size) {
				//Returns the number a sides a piece would have
				var max = size - 1;
				var sides = 0;
				if (x == 0)
					sides++;
				if (y == 0)
					sides++;
				if (z == 0)
					sides++;
				if (z == max)
					sides++;
				if (y == max)
					sides++;
				if (x == max)
					sides++;
				return sides;
			},
			GetPartString: function (size) {
				//gets the part string to help convert the cube from surface to piece and piece to surface
				partLength = size * size * size - (size - 2) * (size - 2) * (size - 2);
				if (partLength > 0) {
					if (partLength == CubeData.PartString.length) {
						return CubeData.PartString;
					} else {
						CubeData.PartString = "";
						var x = 0;
						var y = 0;
						var z = 0;
						var surfaces = 0;
						for (var i = 0; i < size * size * size; i++) {
							z = i % size;//z is incremented first to stay consistent with defining all leftmost pieces first, then bottom most then backmost,
							// so since backmost is the least significant, z is used to follow the cube
							y = Math.floor(i / size) % size;
							x = Math.floor(i / (size * size));
							surfaces = 0;// find out how many sides this piece would have to find out if it is a edge, center or corner.
							if (x == 0 || x == size - 1)
								surfaces++;
							if (y == 0 || y == size - 1)
								surfaces++;
							if (z == 0 || z == size - 1)
								surfaces++;

							switch (surfaces) {
								case 1:
									CubeData.PartString += "N";//N is used for center as c is already used for corner
									break;
								case 2:
									CubeData.PartString += "E";
									break;
								case 3:
									CubeData.PartString += "C";
									break;
								default:
									break;
							}
						}
						return CubeData.PartString;
					}
				} else {
					return "";
				}

			},
			GetPieceCoords: function (index, size) {
				//returns x,y,and z coordinates (with the LDB corner being 0,0,0) of a certain piece index inside the cube 
				var x = 0, y = 0, z = 0;
				var offSet = 0;
				if (index < size * size) {//left layer
					x = 0;
					y = Math.floor(index / size);
					z = index % size;
				} else if (index < size * size + (size - 2) * (size * 2 + 2 * (size - 2))) {//middle layers
					offset = size * size;
					x = Math.floor((index - offset) / (size * 2 + 2 * (size - 2)));// (size * 2 + 2 * (size - 2)) is the number of pieces in one layer 
					//size * 2 represents the top and bottom layers of the middle layer and 2 * (size - 2) represents the center pieces in between the top and bottom
					offset = size * size + x * (size * 2 + 2 * (size - 2));
					x++;
					if (index - offset < size) {//on bottom section
						y = 0;
						z = (index - offset) % size;
					} else if (index - offset < size + 2 * (size - 2)) {//on center pieces
						y = Math.floor((index - offset - size) / 2) + 1;
						if ((index - offset - size) % 2 == 1)
							z = size - 1;
					} else if (index - offset < 2 * size + 2 * (size - 2)) {//on top section
						y = size - 1;
						z = (index - offset - size - 2 * (size - 2)) % size;
					}

				} else if (index < size * size * 2 + (size - 2) * (size * 2 + 2 * (size - 2))) {//on right layer/ exists
					x = size - 1;
					offset = size * size + (size - 2) * (size * 2 + 2 * (size - 2));
					y = Math.floor((index - offset) / size);
					z = (index - offset) % size;
				}
				return [x, y, z];
			},
			GetPieceIndex: function (x, y, z, size) {
				//inverse of get piece coords
				var offset;
				if (x == 0) {
					return y * size + z;
				}
				else if (x == size - 1) {
					return size * size + (size - 2) * (2 * size + 2 * (size - 2)) + y * size + z;
				} else {
					offset = size * size + (x - 1) * (2 * size + 2 * (size - 2));
					if (y == 0) {
						return offset + z;
					} else if (y == size - 1) {
						return offset + 2 * (size - 2) + size + z;
					} else {
						return offset + size + (y - 1) * 2 + Math.floor(z / (size - 1));
					}
				}
				return -1;
			},
			GetLocationType(size, number) {//GetLocationType(size,x,y,z)

				//TODO
				//this methood returns an array describing a piece in  various ways
				//[groupLocation,numberInGoup]
				//groupLocation: the area of a cube that a piece belongs to (0-25), basicly a 3 by 3 if the cube was reduced.

				//numberInGroup: States the number (LDB) it is in the group (starting with 0), corners are always the only one in their group
				/*
				____________
			   |\___\___\___\
			   | \___\___\___\
			   |  \___\___\___\
			   \  |___|___|___|
				\ |___|___|___|
				 \|___|___|___|
		
		
		
				*/
				/*
					
				*/
				var groupLocation, numberInGroup;
				var x, y, z;
				if (arguments.length == 2) {//support both index and coordinates being entered for argument
					var coords = CubeData.GetPieceCoords(number, size);
					x = coords[0];
					y = coords[1];
					z = coords[2];
				} else if (arguments.length == 4) {
					x = number;
					y = arguments[2];
					z = arguments[3];
				}
				if (x > 1 && x < size - 1)//bring stuff down to a 3 by 3 state.
					x = 1;
				if (y > 1 && y < size - 1)
					y = 1;
				if (z > 1 && z < size - 1)
					z = 1;
				if (x > 2)
					x = 2;
				if (y > 2)
					y = 2;
				if (z > 2)
					z = 2;
				if (size == 2) {//if the cube is a 2 by 2, there are no edges.
					if (x == 1)
						x = 2;
					if (y == 1)
						y = 2;
					if (z == 1)
						z = 2;
				}
				switch (x) {
					case 0: {
						switch (y) {
							case 0: {
								switch (z) {
									case 0: groupLocation = 0; break;
									case 1: groupLocation = 1; break;
									case 2: groupLocation = 2; break;
								}
								break;
							}
							case 1: {
								switch (z) {
									case 0: groupLocation = 3; break;
									case 1: groupLocation = 4; break;
									case 2: groupLocation = 5; break;
								}
								break;
							}
							case 2: {
								switch (z) {
									case 0: groupLocation = 6; break;
									case 1: groupLocation = 7; break;
									case 2: groupLocation = 8; break;
								}
								break;
							}
						}
						break;
					}
					case 1: {
						switch (y) {
							case 0: {
								switch (z) {
									case 0: groupLocation = 9; break;
									case 1: groupLocation = 10; break;
									case 2: groupLocation = 11; break;
								}
								break;
							}
							case 1: {
								switch (z) {
									case 0: groupLocation = 12; break;//case 1 is in the middle of the cube
									case 2: groupLocation = 13; break;
								}
								break;
							}
							case 2: {
								switch (z) {
									case 0: groupLocation = 14; break;
									case 1: groupLocation = 15; break;
									case 2: groupLocation = 16; break;
								}
								break;
							}
						}
						break;
					}
					case 2: {
						switch (y) {
							case 0: {
								switch (z) {
									case 0: groupLocation = 17; break;
									case 1: groupLocation = 18; break;
									case 2: groupLocation = 19; break;
								}
								break;
							}
							case 1: {
								switch (z) {
									case 0: groupLocation = 20; break;
									case 1: groupLocation = 21; break;
									case 2: groupLocation = 22; break;
								}
								break;
							}
							case 2: {
								switch (z) {
									case 0: groupLocation = 23; break;
									case 1: groupLocation = 24; break;
									case 2: groupLocation = 25; break;
								}
								break;
							}
						}
						break;
					}
				}

				if ([0, 2, 6, 8, 17, 19, 23, 25].includes(groupLocation)) {
					numberInGroup = 0;//this always true for corners.
				} else if ([1, 3, 5, 7, 9, 11, 14, 16, 18, 20, 22, 24].includes(groupLocation)) {//edges

				} else if ([4, 10, 12, 13, 15, 21].includes(groupLocation)) {//centers

				}



				return [groupLocation, numberInGroup];

			},
			GetRenderCoords(size, number) {
				//returns an x and y translation with a face rotation code. 0 is none(left), 1 is bottom, 2 is back, 3 is front 4 is top, 5 is right.
				//Faces 2,3, and 5 will use a y rotation to get from the left face to the destination face
				//Faces 1 and 4 will use a z rotation
				//also returns a rotation code face wise (to rotate corners and edges to the correct orientation)
				var x, y, z;
				var coords = CubeData.GetPieceCoords(number, size);
				x = coords[0];
				y = coords[1];
				z = coords[2];
				var face = 0;//this refers to the home face of the cubie
				var faceCoords = { x: 0, y: 0 }
				if (x == 0) {//check in LDB order// Left
					//face is already 0
					faceCoords.x = z;
					faceCoords.y = y;
				} else if (y == 0) {//Down
					face = 1;
					faceCoords.x = z;
					faceCoords.y = size - x - 1;
				} else if (z == 0) {//Back
					face = 2;
					faceCoords.x = size - x - 1;
					faceCoords.y = y;
				} else if (z == size - 1) {//Front
					face = 3;
					faceCoords.x = x;
					faceCoords.y = y;
				} else if (y == size - 1) {//Top
					face = 4;
					faceCoords.x = z;
					faceCoords.y = x;
				} else if (x == size - 1) {//Right
					face = 5;
					faceCoords.x = size - z - 1;
					faceCoords.y = y;
				}

				var type = CubeData.GetLocationType(size, 0, faceCoords.y, faceCoords.x)[0];
				var rotation = 0;
				if ([2, 5].includes(type)) {
					rotation = 1;
				} else if ([7, 8].includes(type)) {
					rotation = 2;
				} else if ([3, 6].includes(type)) {
					rotation = 3;
				}
				return [face, faceCoords, rotation];


			},
			CalculateBitLength: function (number) {
				var POT = 1;
				var valueOfPOT = 2;//find the bit length needed to store the max value of algorithm
				while (valueOfPOT < number) {
					valueOfPOT *= 2;
					POT++;
				}
				return POT;
			},
			GetAmountOfData: function (size, format) {
				//returns the number of pieces or surfaces in a cube
				if (format == CubeDataType.Surface) {
					return (size * size * 6);
				} else if (format == CubeDataType.Piece) {
					return (size * size * size - (size - 2) * (size - 2) * (size - 2));
				} else if (format == CubeDataType.Compact) {
					return 8;
				} else if (format == CubeDataType.Fast) {
					return size * size * 6;
				}
				return 0;
			},
			TranslateCube: function (data, format, size) {
				/*
				This function will read the corners and centers to update the color ID's so that when the cube is solved, the colors still follow
				LBD order.
				This means that if a cube has yellow on top instead of red but the color codes are set up so that red is on top, this will
				read the stickers to see if all the red IDs need to be swapped with the Yellow IDs so the code can understand what is going on and when the cube is solved.
				This will also change the Colors on the renderer so that they are all still the same color and the user does not see the translation.
				*/
				//TODO
			},
			PartString: "",
			PieceCodes: ["012", "031", "024", "043", "152", "135", "254", "345",
				"01", "02", "03", "04", "12", "13", "24", "34", "15", "25", "35", "45"]//this lists the possible codes for each piece, starting with the corners, then the edges. Centers are left out as they don't have any invalid combinations
			//Pieces are first defined by their "Home" piece, which is the Leftmost, bottommost, backmost piece, and then continue on on a CW order for the stickers. 
			//Piece number codes will go through all 8 pieces in 8 numbers, then all the rotated pieces, and then the double rotated pieces. A piece type can be identified by Number % 8 .

		};
		var Renderer = {
			Mat4Multiply: function (matA, matB) {
				//multiplies 2 4X4 matricies, returns matrix
				if (matA.length !== matB.length && MatA.length !== 4) {
					return [];
				} else {
					var matC = [matA[0] * matB[0] + matA[1] * matB[4] + matA[2] * matB[8] + matA[3] * matB[12],
					matA[0] * matB[1] + matA[1] * matB[5] + matA[2] * matB[9] + matA[3] * matB[13],
					matA[0] * matB[2] + matA[1] * matB[6] + matA[2] * matB[10] + matA[3] * matB[14],
					matA[0] * matB[3] + matA[1] * matB[7] + matA[2] * matB[11] + matA[3] * matB[15],//row 1

					matA[4] * matB[0] + matA[5] * matB[4] + matA[6] * matB[8] + matA[7] * matB[12],
					matA[4] * matB[1] + matA[5] * matB[5] + matA[6] * matB[9] + matA[7] * matB[13],
					matA[4] * matB[2] + matA[5] * matB[6] + matA[6] * matB[10] + matA[7] * matB[14],
					matA[4] * matB[3] + matA[5] * matB[7] + matA[6] * matB[11] + matA[7] * matB[15],//row 2

					matA[8] * matB[0] + matA[9] * matB[4] + matA[10] * matB[8] + matA[11] * matB[12],
					matA[8] * matB[1] + matA[9] * matB[5] + matA[10] * matB[9] + matA[11] * matB[13],
					matA[8] * matB[2] + matA[9] * matB[6] + matA[10] * matB[10] + matA[11] * matB[14],
					matA[8] * matB[3] + matA[9] * matB[7] + matA[10] * matB[11] + matA[11] * matB[15],//row 3

					matA[12] * matB[0] + matA[13] * matB[4] + matA[14] * matB[8] + matA[15] * matB[12],
					matA[12] * matB[1] + matA[13] * matB[5] + matA[14] * matB[9] + matA[15] * matB[13],
					matA[12] * matB[2] + matA[13] * matB[6] + matA[14] * matB[10] + matA[15] * matB[14],
					matA[12] * matB[3] + matA[13] * matB[7] + matA[14] * matB[11] + matA[15] * matB[15]  //row 4
					];

					return matC;
				}
			},
			Mat3Multiply: function (matA, matB) {
				//multiplies 2 3X3 matricies returns matrix
				if (matA.length !== 9 || matB.length !== 9) {
					return [];
				} else {
					var matC = [matA[0] * matB[0] + matA[1] * matB[3] + matA[2] * matB[6],
					matA[0] * matB[1] + matA[1] * matB[4] + matA[2] * matB[7],
					matA[0] * matB[2] + matA[1] * matB[5] + matA[2] * matB[8],//row 1
					matA[3] * matB[0] + matA[4] * matB[3] + matA[5] * matB[6],
					matA[3] * matB[1] + matA[4] * matB[4] + matA[5] * matB[7],
					matA[3] * matB[2] + matA[4] * matB[5] + matA[5] * matB[8],//row 2
					matA[6] * matB[0] + matA[7] * matB[3] + matA[8] * matB[6],
					matA[6] * matB[1] + matA[7] * matB[4] + matA[8] * matB[7],
					matA[6] * matB[2] + matA[7] * matB[5] + matA[8] * matB[8]//row 3
					];
				}
				return matC;
			},
			Mat3Inverse: function (matA) {
				var matB = [1, 0, 0, 0, 1, 0, 0, 0, 1];
				var det = this.Mat3Determinant(matA);
				if (det != 0) {
					det = 1 / det;
					matB = [det * (matA[4] * matA[8] - matA[5] * matA[7]), -det * (matA[1] * matA[8] - matA[2] * matA[7]), det * (matA[1] * matA[5] - matA[2] * matA[4]),
					-det * (matA[3] * matA[8] - matA[5] * matA[6]), det * (matA[0] * matA[8] - matA[2] * matA[6]), -det * (matA[0] * matA[5] - matA[2] * matA[3]),
					det * (matA[3] * matA[7] - matA[4] * matA[6]), -det * (matA[0] * matA[7] - matA[1] * matA[6]), det * (matA[0] * matA[4] - matA[1] * matA[3])];
				}
				return matB;
			},
			Mat3Determinant: function (matA) {//[0 1 2
				//  3 4 5
				//6 7 8]
				if (matA.length == 9) {
					return (matA[0] * (matA[4] * matA[8] - matA[5] * matA[7]) - matA[1] * (matA[3] * matA[8] - matA[5] * matA[6]) + matA[2] * (matA[3] * matA[7] - matA[4] * matA[6]));
				} else {
					return 0;
				}
			},
			Mat2Determinant: function (matA) {
				return matA[0] * matA[2] - matA[1] * matA[3];
			},
			Mat3Transpose: function (matA) {
				return [matA[0], matA[3], matA[6],
				matA[1], matA[4], matA[7],
				matA[2], matA[5], matA[8]]
			},
			Mat4Transpose: function (matA) {
				return [matA[0], matA[4], matA[8], matA[12],
				matA[1], matA[5], matA[9], matA[13],
				matA[2], matA[6], matA[10], matA[14],
				matA[3], matA[7], matA[11], matA[15]]
			},
			GetModel: function (style, type, data) {
				//creates a new VBO, IBO, and model matrix for a piece using the data varable to have the (upto) 3 color ids
				//old model format [VBO, IBO1(side 1), IBO2(side 2), IBO3(side 3), IBO4(back model) ,matrix,style,type, index count1 (ic), ic2, ic3, ic4,tempMatrix(used for temporary transforms such as turns before they get permanately added)]
				//new model format [VBO,IBO(pointer),faceLocations,matrix,style,type,tempMatrix]
				if (typeof this.Models[style] == "object") {
					var model = [0, 0, [], [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], style, type, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]];
					if (type == 0) {
						model[0] = new Float32Array(this.Models[style].center);
						if (this.Models[style].centerFaces[2] === null) {//create the IBO buffer if it doesn't exist already
							this.Models[style].centerFaces[2] = gl.createBuffer();
							gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.Models[style].centerFaces[2]);
							gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(this.Models[style].centerFaces[0]), gl.STATIC_DRAW);
						}
						model[1] = this.Models[style].centerFaces[2];
						model[2] = this.Models[style].centerFaces[1];
						for (var cl = 0; cl < this.Models[style].centerLocations.length; cl++) {//loops through all stored color location objects, could be unrolled as these should be a constant size
							for (var ci = 0; ci < this.Models[style].centerLocations[cl].color.length; ci++) {//loops through all the color locations stored in the color location objects. Simmilar method is used for id colors
								model[0][this.Models[style].centerLocations[cl].color[ci] + 0] = this.Colors[data[cl]][0];// Applies the color given through data
								model[0][this.Models[style].centerLocations[cl].color[ci] + 1] = this.Colors[data[cl]][1];
								model[0][this.Models[style].centerLocations[cl].color[ci] + 2] = this.Colors[data[cl]][2];
							}
						}
					} else if (type == 1) {
						model[0] = new Float32Array(this.Models[style].edge);
						if (this.Models[style].edgeFaces[2] === null) {//create the IBO buffer if it doesn't exist already

							this.Models[style].edgeFaces[2] = gl.createBuffer();
							gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.Models[style].edgeFaces[2]);
							gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(this.Models[style].edgeFaces[0]), gl.STATIC_DRAW);
						}
						model[1] = this.Models[style].edgeFaces[2];
						model[2] = this.Models[style].edgeFaces[1];

						for (var cl = 0; cl < this.Models[style].edgeLocations.length; cl++) {
							for (var ci = 0; ci < this.Models[style].edgeLocations[cl].color.length; ci++) {
								model[0][this.Models[style].edgeLocations[cl].color[ci] + 0] = this.Colors[data[cl]][0];
								model[0][this.Models[style].edgeLocations[cl].color[ci] + 1] = this.Colors[data[cl]][1];
								model[0][this.Models[style].edgeLocations[cl].color[ci] + 2] = this.Colors[data[cl]][2];
							}
						}
					} else {
						model[0] = new Float32Array(this.Models[style].corner);
						if (this.Models[style].cornerFaces[2] === null) {//create the IBO buffer if it doesn't exist already
							this.Models[style].cornerFaces[2] = gl.createBuffer();
							gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.Models[style].cornerFaces[2]);
							gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(this.Models[style].cornerFaces[0]), gl.STATIC_DRAW);
						}
						model[1] = this.Models[style].cornerFaces[2];
						model[2] = this.Models[style].cornerFaces[1];
						for (var cl = 0; cl < this.Models[style].cornerLocations.length; cl++) {
							for (var ci = 0; ci < this.Models[style].cornerLocations[cl].color.length; ci++) {
								model[0][this.Models[style].cornerLocations[cl].color[ci] + 0] = this.Colors[data[cl]][0];
								model[0][this.Models[style].cornerLocations[cl].color[ci] + 1] = this.Colors[data[cl]][1];
								model[0][this.Models[style].cornerLocations[cl].color[ci] + 2] = this.Colors[data[cl]][2];
							}
						}
					}
					return model;
				} else {
					return [new Float32Array(16), null, [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], style, type, [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]];
				}
			},
			UpdateModel: function (cubie, updateType, data) {
				//updates a model to change the color, id color, or texture
				//update types: 0 is color, 1 is id color, 2 is texture (un used for now)
				if (updateType == 0) {
					if (cubie.type == CubieType.Center) {
						for (var cl = 0; cl < this.Models[cubie.style].centerLocations.length; cl++) {
							for (var ci = 0; ci < this.Models[cubie.style].centerLocations[cl].color.length; ci++) {
								gl.bindBuffer(gl.ARRAY_BUFFER, cubie.model[0]);
								gl.bufferSubData(gl.ARRAY_BUFFER, (this.Models[cubie.style].centerLocations[cl].color[ci]) * 4, new Float32Array(this.Colors[data[(cl + cubie.home) % (cubie.type + 1)]]));//home position shifts how the data should be read
							}
						}
					} else if (cubie.type == CubieType.Edge) {
						for (var cl = 0; cl < this.Models[cubie.style].edgeLocations.length; cl++) {
							for (var ci = 0; ci < this.Models[cubie.style].edgeLocations[cl].color.length; ci++) {
								gl.bindBuffer(gl.ARRAY_BUFFER, cubie.model[0]);
								gl.bufferSubData(gl.ARRAY_BUFFER, (this.Models[cubie.style].edgeLocations[cl].color[ci]) * 4, new Float32Array(this.Colors[data[(cl + cubie.home) % (cubie.type + 1)]]));
							}
						}
					} else if (cubie.type == CubieType.Corner) {
						for (var cl = 0; cl < this.Models[cubie.style].cornerLocations.length; cl++) {//loops through the sides
							for (var ci = 0; ci < this.Models[cubie.style].cornerLocations[cl].color.length; ci++) {//loops through all locations on one side
								gl.bindBuffer(gl.ARRAY_BUFFER, cubie.model[0]);
								gl.bufferSubData(gl.ARRAY_BUFFER, (this.Models[cubie.style].cornerLocations[cl].color[ci]) * 4, new Float32Array(this.Colors[data[(cl + cubie.home) % (cubie.type + 1)]]));
							}
						}
					}
				} else if (updateType == 1) {
					if (cubie.type == CubieType.Center) {
						for (var cl = 0; cl < this.Models[cubie.style].centerLocations.length; cl++) {
							for (var ci = 0; ci < this.Models[cubie.style].centerLocations[cl].id_color.length; ci++) {
								gl.bindBuffer(gl.ARRAY_BUFFER, cubie.model[0]);
								gl.bufferSubData(gl.ARRAY_BUFFER, (this.Models[cubie.style].centerLocations[cl].id_color[ci]) * 4, new Float32Array(data[(cl + cubie.home) % (cubie.type + 1)]));
							}
						}
					} else if (cubie.type == CubieType.Edge) {
						for (var cl = 0; cl < this.Models[cubie.style].edgeLocations.length; cl++) {
							for (var ci = 0; ci < this.Models[cubie.style].edgeLocations[cl].id_color.length; ci++) {
								gl.bindBuffer(gl.ARRAY_BUFFER, cubie.model[0]);
								gl.bufferSubData(gl.ARRAY_BUFFER, (this.Models[cubie.style].edgeLocations[cl].id_color[ci]) * 4, new Float32Array(data[(cl + cubie.home) % (cubie.type + 1)]));
							}
						}
					} else if (cubie.type == CubieType.Corner) {
						for (var cl = 0; cl < this.Models[cubie.style].cornerLocations.length; cl++) {//loops through the sides
							for (var ci = 0; ci < this.Models[cubie.style].cornerLocations[cl].id_color.length; ci++) {//loops through all locations on one side
								gl.bindBuffer(gl.ARRAY_BUFFER, cubie.model[0]);
								gl.bufferSubData(gl.ARRAY_BUFFER, (this.Models[cubie.style].cornerLocations[cl].id_color[ci]) * 4, new Float32Array(data[(cl + cubie.home) % (cubie.type + 1)]));
							}
						}
					}
				}

			},
			MainUniforms: {
				main_texture: -1,
				bump_texture: -1,
				back_color: -1,
				light_direction: -1,
				overlay_color: -1,
				world_matrix: -1,
				normal_matrix: -1,
				model_matrix: -1,
				perspective_matrix: -1,
				texture_mode: -1,
				camera_postion: -1,
				back_light: -1
			},
			MapUniforms: {
				world_matrix: -1,
				model_matrix: -1,
				perspective_matrix: -1
			},
			MainAttributes: {
				point: -1,
				color: -1,
				normal: -1,
				main_uv: -1,
				normal_uv: -1,
				u_bitangent: -1,
				v_bitangent: -1
			},
			MapAttributes: {
				point: -1,
				id_color: -1
			},
			DebugUniforms: {
				main_texture: -1
			},
			DebugAttributes: {
				point: -1,
				uv: -1
			},
			Colors: [[0.0, 0.0, 1.0], [0.901, 0.5, 0.0], [1.0, 1.0, 0.0], [1.0, 1.0, 1.0], [1.0, 0.0, 0.0], [0.0, 1.0, 0.0]],//Blue, Orange, Yellow, White,  Red, Green//b,o,y,w,r,g
			MapRenderBuffer: null,
			MapDepthBuffer: null,
			MapTexture: null,//Used to access the info of map at certain coordinates
			MapSize: 1024,
			MainTexture: null,//Used Differently between Modes
			BumpTexture: null,
			MainProgram: null,
			MapProgram: null,
			DebugProgram: null,
			gl: null,
			canvas: null,
			ct: null,
			bct: null,
			textureCanvas: null,
			bumpCanvas: null,
			MapMode: false,//Tells if we are rendering to the map or main screen.
			RenderMode: 0,//Tells about texture info. In mode 0, if texture is black it is a sticker color, white is background color, in mode 1 alpha 0 is sicker color, else, it is the texture data. In mode 2 it just displays texture
			LightDirection: [-0.5, -0.5, -2],
			HightlightColor: [0.5, 0.5, 0.5],
			BackColor: [0.9, 0.9, 0.9],
			ErrorColor: [1.0, 0.1, 0.1],
			ErrorAnimationColor: [0.1, 0.1, 0.1],
			ErrorTimer: 0,
			ErrorSpeed: 50,
			BackFlash: false,
			FieldOfView: 90,
			CameraAngle: [0, 0, 0],
			BumpImage: null,
			SetUp: function () {
				//sets up Webgl
				this.HasRun = true;
				this.canvas = document.createElement("canvas");
				this.textureCanvas = document.createElement("canvas");
				this.bumpCanvas = document.createElement("canvas");
				this.canvas.width = window.innerWidth;
				this.canvas.height = window.innerHeight;
				document.getElementById("canvas").appendChild(this.canvas);/*The div element with the id 
		canvas is the holder that holds the canvas allowing
		it to fit into the page like formating style with ease.*/
				this.gl = this.canvas.getContext("webgl", {
					alpha: false, antialias: true
				}) || canvas_gl_main.getContext("experimental-webgl", {
					alpha: false, antialias: true
				});//gotta support that IE
				if (this.gl == null) {
					alert("Could not start up WebGL!\nPlease make sure you have a WebGL 1.0 enabled browser and try again!\nThis works best in Chrome.");
					throw "Error: requested webgl context returned: " + this.gl;
				}
				this.textureCanvas.width = 1024;
				this.textureCanvas.height = 1024;
				this.ct = this.textureCanvas.getContext("2d");
				this.ct.fillStyle = "black";
				this.ct.strokeStyle = "white";
				this.ct.lineWidth = 100;
				this.ct.lineJoin = "round";
				this.ct.fillRect(0, 0, 1024, 1024)
				this.ct.strokeRect(0, 0, 1024, 1024);

				this.bumpCanvas.width = 1024;
				this.bumpCanvas.height = 1024;
				this.bct = this.bumpCanvas.getContext("2d");
				this.bct.fillStyle = "rgb(128,128,255)";
				this.bct.fillRect(0, 0, 1024, 1024)

				/*
				for(var x= 0;x<32;x++){
					for(var y= 0;y<32;y++){
						this.bct.fillStyle = "rgb("+Math.floor(Math.random()*36+109)+","+Math.floor(Math.random()*36+109)+","+Math.floor(Math.random()*128+128)+")";
						
						this.bct.fillRect(x*32,y*32,32,32);
					}
				}//*/
				for (var i = 0; i < 500; i++) {
					this.bct.fillStyle = "rgb(" + Math.floor(Math.random() * 256) + "," + Math.floor(Math.random() * 256) + ",255)";
					this.bct.beginPath();
					this.bct.fillRect(Math.floor(Math.random() * 1024) + 60, Math.floor(Math.random() * 1024) + 60, 10, 10)
				}
				this.bct.strokeStyle = "rgb(128,128,255)";
				this.bct.lineWidth = 100;
				this.bct.lineJoin = "round";
				this.bct.strokeRect(0, 0, 1024, 1024);
				//*
				this.bct.lineWidth = 1;
				this.bct.strokeStyle = "rgb(128,0,255)";
				this.bct.beginPath();
				this.bct.moveTo(60, 60);
				this.bct.lineTo(964, 60);
				this.bct.stroke();
				this.bct.strokeStyle = "rgb(128,255,255)";
				this.bct.beginPath();
				this.bct.moveTo(60, 964);
				this.bct.lineTo(964, 964);
				this.bct.stroke();
				this.bct.strokeStyle = "rgb(255,128,255)";
				this.bct.beginPath();
				this.bct.moveTo(964, 60);
				this.bct.lineTo(964, 964);
				this.bct.stroke();
				this.bct.strokeStyle = "rgb(0,128,255)";
				this.bct.beginPath();
				this.bct.moveTo(60, 60);
				this.bct.lineTo(60, 964);
				this.bct.stroke();


				//*/
				//	this.bumpImage = new Image(); Removed as I don't own these textures and should no use them for now
				//this.bumpImage.src = "vpZuv.png";
				//*/
				/*
				this.bumpImage.onload = function(){
					gl.useProgram(Renderer.MainProgram);
					gl.activeTexture(gl.TEXTURE2);
						if(!Renderer.BumpTexture){
							
							Renderer.BumpTexture = gl.createTexture();
						}
						Renderer.bct.drawImage(Renderer.bumpImage,50,50,924,924);
						gl.bindTexture(gl.TEXTURE_2D, Renderer.BumpTexture);
						gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, Renderer.bumpCanvas);
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);
						gl.generateMipmap(gl.TEXTURE_2D);
						
						gl.uniform1i(Renderer.MainUniforms.bump_texture,2);
				};//*/
				gl = this.gl;//so I don't have to keep calling it this.gl
				gl.clearColor(0.0, 0.0, 0.0, 1.0);
				gl.enable(gl.DEPTH_TEST);
				gl.depthFunc(gl.LEQUAL);
				gl.clearDepth(1.0);
				gl.enable(gl.CULL_FACE);
				this.Clear();

				//set up the programs.

				//Main program
				mainVertexShader = gl.createShader(gl.VERTEX_SHADER);
				gl.shaderSource(mainVertexShader, mainVertexSource);
				gl.compileShader(mainVertexShader);
				if (!gl.getShaderParameter(mainVertexShader, gl.COMPILE_STATUS)) {
					alert("ERROR IN MAIN VERTEX SHADER : " + gl.getShaderInfoLog(mainVertexShader));
					throw "ERROR IN MAIN VERTEX SHADER : " + gl.getShaderInfoLog(mainVertexShader);
				}

				mainFragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
				gl.shaderSource(mainFragmentShader, mainFragmentSource);
				gl.compileShader(mainFragmentShader);
				if (!gl.getShaderParameter(mainFragmentShader, gl.COMPILE_STATUS)) {
					alert("ERROR IN MAIN FRAGMENT SHADER : " + gl.getShaderInfoLog(mainFragmentShader));
					throw "ERROR IN MAIN FRAGMENT SHADER : " + gl.getShaderInfoLog(mainFragmentShader);
				}

				this.MainProgram = gl.createProgram();
				gl.attachShader(this.MainProgram, mainVertexShader);
				gl.attachShader(this.MainProgram, mainFragmentShader);
				gl.linkProgram(this.MainProgram);


				this.MainUniforms.main_texture = gl.getUniformLocation(this.MainProgram, "main_texture");
				this.MainUniforms.bump_texture = gl.getUniformLocation(this.MainProgram, "bump_texture");
				this.MainUniforms.back_color = gl.getUniformLocation(this.MainProgram, "back_color");
				this.MainUniforms.light_direction = gl.getUniformLocation(this.MainProgram, "light_direction");
				this.MainUniforms.overlay_color = gl.getUniformLocation(this.MainProgram, "overlay_color");
				this.MainUniforms.world_matrix = gl.getUniformLocation(this.MainProgram, "world_matrix");
				this.MainUniforms.normal_matrix = gl.getUniformLocation(this.MainProgram, "normal_matrix");
				this.MainUniforms.model_matrix = gl.getUniformLocation(this.MainProgram, "model_matrix");
				this.MainUniforms.perspective_matrix = gl.getUniformLocation(this.MainProgram, "perspective_matrix");
				this.MainUniforms.texture_mode = gl.getUniformLocation(this.MainProgram, "texture_mode");
				this.MainUniforms.camera_postion = gl.getUniformLocation(this.MainProgram, "camera_position");
				this.MainUniforms.back_light = gl.getUniformLocation(this.MainProgram, "backLight");

				this.MainAttributes.point = gl.getAttribLocation(this.MainProgram, "point");
				this.MainAttributes.color = gl.getAttribLocation(this.MainProgram, "color");
				this.MainAttributes.normal = gl.getAttribLocation(this.MainProgram, "normal");
				this.MainAttributes.u_bitangent = gl.getAttribLocation(this.MainProgram, "u_bitangent");
				this.MainAttributes.v_bitangent = gl.getAttribLocation(this.MainProgram, "v_bitangent");
				this.MainAttributes.main_uv = gl.getAttribLocation(this.MainProgram, "main_uv");
				this.MainAttributes.normal_uv = gl.getAttribLocation(this.MainProgram, "normal_uv");


				if (!gl.getProgramParameter(this.MainProgram, gl.LINK_STATUS)) {
					alert("UNKNOWN ERROR IN Main PROGRAM");
					throw "Unknown error in main program";
				}
				gl.useProgram(this.MainProgram);
				for (a in this.MainAttributes) {
					gl.enableVertexAttribArray(this.MainAttributes[a]);
				}


				//Map program
				mapVertexShader = gl.createShader(gl.VERTEX_SHADER);
				gl.shaderSource(mapVertexShader, mapVertexSource);
				gl.compileShader(mapVertexShader);
				if (!gl.getShaderParameter(mapVertexShader, gl.COMPILE_STATUS)) {
					alert("ERROR IN MAP VERTEX SHADER : " + gl.getShaderInfoLog(mapVertexShader));
					throw "ERROR IN MAP VERTEX SHADER : " + gl.getShaderInfoLog(mapVertexShader);
				}

				mapFragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
				gl.shaderSource(mapFragmentShader, mapFragmentSource);
				gl.compileShader(mapFragmentShader);
				if (!gl.getShaderParameter(mapFragmentShader, gl.COMPILE_STATUS)) {
					alert("ERROR IN MAP FRAGMENT SHADER : " + gl.getShaderInfoLog(mapFragmentShader));
					throw "ERROR IN MAP FRAGMENT SHADER : " + gl.getShaderInfoLog(mapFragmentShader);
				}

				this.MapProgram = gl.createProgram();
				gl.attachShader(this.MapProgram, mapVertexShader);
				gl.attachShader(this.MapProgram, mapFragmentShader);
				gl.linkProgram(this.MapProgram);


				this.MapUniforms.world_matrix = gl.getUniformLocation(this.MapProgram, "world_matrix");
				this.MapUniforms.model_matrix = gl.getUniformLocation(this.MapProgram, "model_matrix");
				this.MapUniforms.perspective_matrix = gl.getUniformLocation(this.MapProgram, "perspective_matrix");

				this.MapAttributes.point = gl.getAttribLocation(this.MapProgram, "point");
				this.MapAttributes.id_color = gl.getAttribLocation(this.MapProgram, "id_color");


				if (!gl.getProgramParameter(this.MapProgram, gl.LINK_STATUS)) {
					alert("UNKNOWN ERROR IN Map PROGRAM");
					throw "Unknown error in Map program";
				}
				gl.useProgram(this.MapProgram);
				for (a in this.MapAttributes) {
					gl.enableVertexAttribArray(this.MapAttributes[a]);
				}

				//debug program
				debugVertexShader = gl.createShader(gl.VERTEX_SHADER);
				gl.shaderSource(debugVertexShader, debugVertexSource);
				gl.compileShader(debugVertexShader);
				if (!gl.getShaderParameter(debugVertexShader, gl.COMPILE_STATUS)) {
					alert("ERROR IN debug VERTEX SHADER : " + gl.getShaderInfoLog(debugVertexShader));
					throw "ERROR IN debug VERTEX SHADER : " + gl.getShaderInfoLog(debugVertexShader);
				}

				debugFragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
				gl.shaderSource(debugFragmentShader, debugFragmentSource);
				gl.compileShader(debugFragmentShader);
				if (!gl.getShaderParameter(debugFragmentShader, gl.COMPILE_STATUS)) {
					alert("ERROR IN debug FRAGMENT SHADER : " + gl.getShaderInfoLog(debugFragmentShader));
					throw "ERROR IN debug FRAGMENT SHADER : " + gl.getShaderInfoLog(debugFragmentShader);
				}

				this.DebugProgram = gl.createProgram();
				gl.attachShader(this.DebugProgram, debugVertexShader);
				gl.attachShader(this.DebugProgram, debugFragmentShader);
				gl.linkProgram(this.DebugProgram);


				this.DebugUniforms.main_texture = gl.getUniformLocation(this.DebugProgram, "main_texture");

				this.DebugAttributes.point = gl.getAttribLocation(this.DebugProgram, "point");
				this.DebugAttributes.uv = gl.getAttribLocation(this.DebugProgram, "uv");


				if (!gl.getProgramParameter(this.DebugProgram, gl.LINK_STATUS)) {
					alert("UNKNOWN ERROR IN Debug PROGRAM");
					throw "Unknown error in Debug program";
				}
				gl.useProgram(this.DebugProgram);
				for (a in this.DebugAttributes) {
					gl.enableVertexAttribArray(this.DebugAttributes[a]);
				}

				gl.useProgram(this.MainProgram);
				gl.activeTexture(gl.TEXTURE0);
				this.MapTexture = gl.createTexture();
				gl.bindTexture(gl.TEXTURE_2D, this.MapTexture);
				gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.MapSize, this.MapSize, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);//This is line of code is from webgl fundamentals 

				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
				this.MapBuffer = gl.createFramebuffer();
				gl.bindFramebuffer(gl.FRAMEBUFFER, this.MapBuffer);
				gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.MapTexture, 0);
				this.MapDepthBuffer = gl.createRenderbuffer();
				gl.bindRenderbuffer(gl.RENDERBUFFER, this.MapDepthBuffer);

				// make a depth buffer and the same size as the targetTexture
				gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, this.MapSize, this.MapSize);
				gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, this.MapDepthBuffer);


				this.UpdateTextures(this.textureCanvas, true);

				debugVBuffer = gl.createBuffer();//convert the arrays to webgl buffers
				gl.bindBuffer(gl.ARRAY_BUFFER, debugVBuffer);
				gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
					0.0, 0.0, 0.0, 0.0,
					1.0, 0.0, 1.0, 0.0,
					1.0, 1.0, 1.0, 1.0,
					0.0, 1.0, 0.0, 1.0]), gl.STATIC_DRAW);
				debugEBuffer = gl.createBuffer();//convert the arrays to webgl buffers
				gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, debugEBuffer);
				gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array([0, 1, 2, 0, 2, 3]), gl.STATIC_DRAW);


			},
			SetUpMap: function (shouldClear = false) {//prepares for rendering to the map
				gl.bindFramebuffer(gl.FRAMEBUFFER, this.MapBuffer);
				gl.clearColor(1.0, 1.0, 1.0, 1.0);
				if (shouldClear) {
					this.Clear();
				}
				gl.viewport(0, 0, this.MapSize, this.MapSize);
			},
			SetUpMain: function (shouldClear = false) {//prepares for rendering to the main screen
				gl.bindFramebuffer(gl.FRAMEBUFFER, null);
				if (this.BackFlash) {
					gl.clearColor(this.ErrorAnimationColor[0], this.ErrorAnimationColor[1], this.ErrorAnimationColor[2], 1.0);
				} else {
					gl.clearColor(0.0, 0.0, 0.0, 1.0);
				}
				if (shouldClear) {
					this.Clear();
				}
				gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
			},
			setAts: function (pn) {

				//Attributes go point(3),color(3),normal(3),id_color(3)(used by map),main_uv(2),normal_uv(2)
				if (pn === 0) {
					//gl.useProgram(this.MainProgram);
					gl.vertexAttribPointer(this.MainAttributes.point, 3, gl.FLOAT, false, 4 * 22, 0);
					gl.vertexAttribPointer(this.MainAttributes.color, 3, gl.FLOAT, false, 4 * 22, 3 * 4);
					gl.vertexAttribPointer(this.MainAttributes.normal, 3, gl.FLOAT, false, 4 * 22, 6 * 4);
					gl.vertexAttribPointer(this.MainAttributes.main_uv, 2, gl.FLOAT, false, 4 * 22, 12 * 4);
					gl.vertexAttribPointer(this.MainAttributes.normal_uv, 2, gl.FLOAT, false, 4 * 22, 14 * 4);
					gl.vertexAttribPointer(this.MainAttributes.u_bitangent, 3, gl.FLOAT, false, 4 * 22, 16 * 4);
					gl.vertexAttribPointer(this.MainAttributes.v_bitangent, 3, gl.FLOAT, false, 4 * 22, 19 * 4);
				} else if (pn === 1) {
					//gl.useProgram(this.MapProgram);
					gl.vertexAttribPointer(this.MapAttributes.point, 3, gl.FLOAT, false, 4 * 22, 0);
					gl.vertexAttribPointer(this.MapAttributes.id_color, 3, gl.FLOAT, false, 4 * 22, 9 * 4);
				} else if (pn === 2) {
					//gl.useProgram(this.DebugProgram);
					gl.vertexAttribPointer(this.DebugAttributes.point, 2, gl.FLOAT, false, 4 * 4, 0);
					gl.vertexAttribPointer(this.DebugAttributes.uv, 2, gl.FLOAT, false, 4 * 4, 2 * 4);
				}
			},
			SetUpCamera: function () {
				//sets up the uniforms

				this.canvas.width = window.innerWidth;
				this.canvas.height = window.innerHeight;
				this.near = 1;
				this.far = 100;
				var width = gl.drawingBufferWidth;
				var height = gl.drawingBufferHeight;
				var f = Math.tan(Math.PI * 0.5 - 0.5 * this.FieldOfView * PR);
				var rangeInv = 1.0 / (this.near - this.far);

				var psm = [
					f / (width / height), 0, 0, 0,
					0, f, 0, 0,
					0, 0, (this.near + this.far) * rangeInv, -1,
					0, 0, this.near * this.far * rangeInv * 2, 0
				];
				var worldMat = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
				var t1 = [1, 0, 0, 0,
					0, 1, 0, 0,
					0, 0, 1, trans,
					0, 0, 0, 1];
				var rym = [Math.cos(degy * PR), 0, -Math.sin(degy * PR), 0,
					0, 1, 0, 0,
				Math.sin(degy * PR), 0, Math.cos(degy * PR), 0,
					0, 0, 0, 1];
				var rxm = [1, 0, 0, 0,
					0, Math.cos(degx * PR), Math.sin(degx * PR), 0,
					0, -Math.sin(degx * PR), Math.cos(degx * PR), 0,
					0, 0, 0, 1];
				var rzm = [Math.cos(degz * PR), -Math.sin(degz * PR), 0, 0,
				Math.sin(degz * PR), Math.cos(degz * PR), 0, 0,
					0, 0, 1, 0,
					0, 0, 0, 1];

				worldMat = this.Mat4Multiply(worldMat, t1);
				worldMat = this.Mat4Multiply(worldMat, rym);
				worldMat = this.Mat4Multiply(worldMat, rzm);
				worldMat = this.Mat4Multiply(worldMat, rxm);
				//Renderer.UpdateTextures(this.textureCanvas,true);
				this.SetUpMap(true);
				gl.useProgram(this.MapProgram);
				gl.uniformMatrix4fv(this.MapUniforms.world_matrix, false, Renderer.Mat4Transpose(worldMat));
				gl.uniformMatrix4fv(this.MapUniforms.model_matrix, false, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
				gl.uniformMatrix4fv(this.MapUniforms.perspective_matrix, false, psm);

				this.SetUpMain(true);
				gl.useProgram(this.MainProgram);
				gl.uniformMatrix4fv(this.MainUniforms.world_matrix, false, Renderer.Mat4Transpose(worldMat));
				gl.uniformMatrix4fv(this.MainUniforms.model_matrix, false, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
				gl.uniformMatrix4fv(this.MainUniforms.perspective_matrix, false, psm);
				gl.uniform1i(this.MainUniforms.texture_mode, this.RenderMode);
				gl.uniform3fv(this.MainUniforms.light_direction, this.LightDirection);
				gl.uniform3fv(this.MainUniforms.back_color, this.BackColor);
				gl.uniform3fv(this.MainUniforms.overlay_color, this.HightlightColor);
				gl.uniform3fv(this.MainUniforms.camera_postion, [0, 0, -trans]);



			},
			RenderCubies: function (cubies = [new Cubie(0, 0, [0, 0, 0])], mapRender = false, cubeMatrix = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]) {
				//Renders the given cubies passed in an array of objects.
				//Must call camera Set up before using this function!
				//set up the uniforms
				Renderer.SetUpMain();

				gl.useProgram(Renderer.MainProgram);
				for (var c = 0; c < cubies.length; c++) {
					//new model format [VBO,IBO(pointer),faceLocations,matrix,style,type,tempMatrix]
					var cubie = cubies[c];
					var modelMat = Renderer.Mat4Multiply(cubeMatrix, cubie.model[6]);
					modelMat = Renderer.Mat4Multiply(modelMat, cubie.model[3]);
					gl.bindBuffer(gl.ARRAY_BUFFER, cubie.model[0]);
					gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubie.model[1]);

					this.setAts(0);
					var cubeTo3 = this.Mat3Inverse([modelMat[0], modelMat[1], modelMat[2], modelMat[4], modelMat[5], modelMat[6], modelMat[8], modelMat[9], modelMat[10]

					]);//transpose removed to send in correctly ordered value to webgl
					gl.uniformMatrix4fv(this.MainUniforms.model_matrix, false, Renderer.Mat4Transpose(modelMat));
					gl.uniformMatrix3fv(this.MainUniforms.normal_matrix, false, cubeTo3);
					if (cubie.inError) {
						gl.uniform3fv(this.MainUniforms.back_color, this.ErrorAnimationColor);
						gl.uniform1f(this.MainUniforms.back_light, true);
					} else {
						gl.uniform3fv(this.MainUniforms.back_color, this.BackColor);

						gl.uniform1f(this.MainUniforms.back_light, false);
					}

					for (var i = 0; i < 4; i++) {
						if (i < cubie.type + 2) {

							if (cubie.highlightedSides[i]) {
								gl.uniform3fv(this.MainUniforms.overlay_color, this.HightlightColor);
							} else {
								gl.uniform3fv(this.MainUniforms.overlay_color, [1.0, 1.0, 1.0]);
							}

							/*if(mapRender){
								Renderer.SetUpMap(false);
								gl.uniformMatrix4fv(this.MapUniforms.model_matrix,false,Renderer.Mat4Transpose(modelMat));
								gl.drawElements(gl.TRIANGLES, cubie.model[2][i*2+1], gl.UNSIGNED_SHORT, cubie.model[2][i*2]*2); //*2 because each number is 2 bytes
								Renderer.SetUpMain(false);
							}else{*/
							//}


							gl.drawElements(gl.TRIANGLES, cubie.model[2][i * 2 + 1], gl.UNSIGNED_SHORT, cubie.model[2][i * 2] * 2);

						}


					}
				}
				if (mapRender) {
					Renderer.SetUpMap(false);
					gl.useProgram(Renderer.MapProgram);
					for (var c = 0; c < cubies.length; c++) {
						//new model format [VBO,IBO(pointer),faceLocations,matrix,style,type,tempMatrix]
						var cubie = cubies[c];
						var modelMat = Renderer.Mat4Multiply(cubeMatrix, cubie.model[6]);
						modelMat = Renderer.Mat4Multiply(modelMat, cubie.model[3]);
						gl.bindBuffer(gl.ARRAY_BUFFER, cubie.model[0]);
						gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubie.model[1]);
						gl.uniformMatrix4fv(this.MapUniforms.model_matrix, false, Renderer.Mat4Transpose(modelMat));
						this.setAts(1);

						for (var i = 0; i < 3; i++) {
							if (i < cubie.type + 1) {
								gl.drawElements(gl.TRIANGLES, cubie.model[2][i * 2 + 1], gl.UNSIGNED_SHORT, cubie.model[2][i * 2] * 2); //*2 because each number is 2 bytes
							}
						}//end face loop			
					}//end cubie loop

					Renderer.SetUpMain(false);
				}//end map


			},
			UpdateTextures: function (source, isPOT) {
				gl.useProgram(this.MainProgram);
				gl.activeTexture(gl.TEXTURE1);
				if (!this.MainTexture) {

					this.MainTexture = gl.createTexture();
				}
				gl.bindTexture(gl.TEXTURE_2D, this.MainTexture);
				gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, source);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);
				if (isPOT) {
					gl.generateMipmap(gl.TEXTURE_2D);
				}
				gl.uniform1i(this.MainUniforms.main_texture, 1);

				gl.activeTexture(gl.TEXTURE2);
				if (!this.BumpTexture) {

					this.BumpTexture = gl.createTexture();
				}
				gl.bindTexture(gl.TEXTURE_2D, this.BumpTexture);
				gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this.bumpCanvas);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);
				if (isPOT) {
					gl.generateMipmap(gl.TEXTURE_2D);
				}
				gl.uniform1i(this.MainUniforms.bump_texture, 2);
			},
			Clear: function () {//clears the current webgl frame
				gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
				gl.flush();
			},
			HasRun: false,
			Models: [
				{
					//do not put these arrays in float 32 in this area of the code.
					center: [-0.5, -0.5, -0.5, 0.0, 0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0,//Left
					-0.5, -0.5, 0.5, 0.0, 0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0,
					-0.5, 0.5, 0.5, 0.0, 0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0,
					-0.5, 0.5, -0.5, 0.0, 0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0,

					-0.5, -0.5, -0.5, 0.0, 0.0, 0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0,//bottom
						0.5, -0.5, -0.5, 0.0, 0.0, 0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0,
						0.5, -0.5, 0.5, 0.0, 0.0, 0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0,
					-0.5, -0.5, 0.5, 0.0, 0.0, 0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0,

						0.5, -0.5, -0.5, 0.0, 0.0, 0.0, 0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 1.0, 0.0,//back
					-0.5, -0.5, -0.5, 0.0, 0.0, 0.0, 0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 1.0, 0.0,
					-0.5, 0.5, -0.5, 0.0, 0.0, 0.0, 0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 1.0, 0.0,
						0.5, 0.5, -0.5, 0.0, 0.0, 0.0, 0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 1.0, 0.0,

					-0.5, -0.5, 0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0,  //front
						0.5, -0.5, 0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0,
						0.5, 0.5, 0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0,
					-0.5, 0.5, 0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0,

					-0.5, 0.5, 0.5, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, -1.0, //top
						0.5, 0.5, 0.5, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, -1.0,
						0.5, 0.5, -0.5, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, -1.0,
					-0.5, 0.5, -0.5, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, -1.0,

						0.5, -0.5, 0.5, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -1.0, 0.0, 1.0, 0.0, //right
						0.5, -0.5, -0.5, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -1.0, 0.0, 1.0, 0.0,
						0.5, 0.5, -0.5, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -1.0, 0.0, 1.0, 0.0,
						0.5, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -1.0, 0.0, 1.0, 0.0
					],//The pre built buffers, color is input by the Render.GetModel and UpdateModel functions


					edge: [-0.5, -0.5, -0.5, 0.0, 0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0,//Left
					-0.5, -0.5, 0.5, 0.0, 0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0,
					-0.5, 0.5, 0.5, 0.0, 0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0,
					-0.5, 0.5, -0.5, 0.0, 0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0,

					-0.5, -0.5, -0.5, 0.0, 0.0, 0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0,//bottom
						0.5, -0.5, -0.5, 0.0, 0.0, 0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0,
						0.5, -0.5, 0.5, 0.0, 0.0, 0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0,
					-0.5, -0.5, 0.5, 0.0, 0.0, 0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0,

						0.5, -0.5, -0.5, 0.0, 0.0, 0.0, 0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 1.0, 0.0,//back
					-0.5, -0.5, -0.5, 0.0, 0.0, 0.0, 0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 1.0, 0.0,
					-0.5, 0.5, -0.5, 0.0, 0.0, 0.0, 0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 1.0, 0.0,
						0.5, 0.5, -0.5, 0.0, 0.0, 0.0, 0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 1.0, 0.0,

					-0.5, -0.5, 0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0,//front
						0.5, -0.5, 0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0,
						0.5, 0.5, 0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0,
					-0.5, 0.5, 0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0,

					-0.5, 0.5, 0.5, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, -1.0, //top
						0.5, 0.5, 0.5, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, -1.0,
						0.5, 0.5, -0.5, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, -1.0,
					-0.5, 0.5, -0.5, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, -1.0,

						0.5, -0.5, 0.5, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -1.0, 0.0, 1.0, 0.0,//right
						0.5, -0.5, -0.5, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -1.0, 0.0, 1.0, 0.0,
						0.5, 0.5, -0.5, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -1.0, 0.0, 1.0, 0.0,
						0.5, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -1.0, 0.0, 1.0, 0.0
					],
					//Attributes go point(3),color(3),normal(3),id_color(3)(used by map),main_uv(2),normal_uv(2), vectors (6)


					corner: [-0.5, -0.5, -0.5, 0.0, 0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0,//Left
					-0.5, -0.5, 0.5, 0.0, 0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0,
					-0.5, 0.5, 0.5, 0.0, 0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0,
					-0.5, 0.5, -0.5, 0.0, 0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0,

					-0.5, -0.5, -0.5, 0.0, 0.0, 0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0,//bottom
						0.5, -0.5, -0.5, 0.0, 0.0, 0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0,
						0.5, -0.5, 0.5, 0.0, 0.0, 0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0,
					-0.5, -0.5, 0.5, 0.0, 0.0, 0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0,

						0.5, -0.5, -0.5, 0.0, 0.0, 0.0, 0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 1.0, 0.0,//back
					-0.5, -0.5, -0.5, 0.0, 0.0, 0.0, 0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, -1.0, 0.0, 0.0, 0.0, 1.0, 0.0,
					-0.5, 0.5, -0.5, 0.0, 0.0, 0.0, 0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0, -1.0, 0.0, 0.0, 0.0, 1.0, 0.0,
						0.5, 0.5, -0.5, 0.0, 0.0, 0.0, 0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, -1.0, 0.0, 0.0, 0.0, 1.0, 0.0,

					-0.5, -0.5, 0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0,//front
						0.5, -0.5, 0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0,
						0.5, 0.5, 0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0,
					-0.5, 0.5, 0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0,

					-0.5, 0.5, 0.5, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, -1.0, //top
						0.5, 0.5, 0.5, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, -1.0,
						0.5, 0.5, -0.5, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, -1.0,
					-0.5, 0.5, -0.5, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, -1.0,

						0.5, -0.5, 0.5, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -1.0, 0.0, 1.0, 0.0,//right
						0.5, -0.5, -0.5, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -1.0, 0.0, 1.0, 0.0,
						0.5, 0.5, -0.5, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -1.0, 0.0, 1.0, 0.0,
						0.5, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -1.0, 0.0, 1.0, 0.0


					],
					//the mainTexture defines where the color is displayed with alpha 0.0 (when in mode 1)
					//These are built with X- being the front main surface, Y- being the bottom and Z- being the left so defalut corners will
					//be for the bottom left, furthest from the camera, Default edges will be left bottom, 
					//Defalut centers will be left, The models will be on a base 1 basis where each Cubie is 1.0 by 1.0 by 1.0 large. 
					//Cubies will range from -0.5 to 0.5 for the main part of the cubie for fitting with other parts of the cube. 
					//Extra parts such as connectors may be added beyond this limit but will not change how the size of the cube is treated
					//Cube will be automaticaly scaled using a scaling Matrix to fit the users screen best.
					centerLocations: [{ color: [3, 25, 47, 69], id_color: [9, 31, 53, 75] }],
					edgeLocations: [{ color: [3, 25, 47, 69], id_color: [9, 31, 53, 75] }, { color: [91, 113, 135, 157], id_color: [97, 119, 141, 163] }],
					cornerLocations: [{ color: [3, 25, 47, 69], id_color: [9, 31, 53, 75] }, { color: [91, 113, 135, 157], id_color: [97, 119, 141, 163] }, { color: [179, 201, 223, 245], id_color: [185, 207, 229, 251] }],//these are used to find the locations for the color and id_color inputs for each side to do a sub buffer when the colors need an update. [color:[start of color index], id_color:[19,23,ect.]]     Up to 3 color indexes are made depending on the colors the part needs 

					centerFaces: [[0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13, 14, 12, 14, 15, 16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23], [0, 6, 6, 30], null],
					edgeFaces: [[0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13, 14, 12, 14, 15, 16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23], [0, 6, 6, 6, 12, 24], null],
					cornerFaces: [[0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13, 14, 12, 14, 15, 16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23], [0, 6, 6, 6, 12, 6, 18, 18], null]//separeated as to help with selecting a side to hilight when hovered over
					//New, E buffers (Faces) are now stored in 1 buffer that is shared among ALL CUBIES of the same type and style. This will cut down memory and and more importantly, drop the number of required uploads to buffers.
					//so instead of [[face1],[face2],[face3],[body]] it will go [[face1,face2,face3,body],[face1Start,face1length....],buffer]	
					//the cube can be broken into 4 parts, 1 for each color (3), and then another part that is not tied to a color but still renders as part of the piece. (in the current model, this is nothing)
				},
				{
					//do not put these arrays in float 32 in this area of the code.
					center: [-0.5, -0.5, -0.5, 0.0, 0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0,//Left
					-0.5, -0.5, 0.5, 0.0, 0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0,
					-0.5, 0.5, 0.5, 0.0, 0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0,
					-0.5, 0.5, -0.5, 0.0, 0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0


					],//The pre built buffers, color is input by the Render.GetModel and UpdateModel functions


					edge: [-0.5, -0.5, -0.5, 0.0, 0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0,//Left
					-0.5, -0.5, 0.5, 0.0, 0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0,
					-0.5, 0.5, 0.5, 0.0, 0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0,
					-0.5, 0.5, -0.5, 0.0, 0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0,

					-0.5, -0.5, -0.5, 0.0, 0.0, 0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0,//bottom
						0.5, -0.5, -0.5, 0.0, 0.0, 0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0,
						0.5, -0.5, 0.5, 0.0, 0.0, 0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0,
					-0.5, -0.5, 0.5, 0.0, 0.0, 0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0


					],
					//Attributes go point(3),color(3),normal(3),id_color(3)(used by map),main_uv(2),normal_uv(2), vectors (6)


					corner: [-0.5, -0.5, -0.5, 0.0, 0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0,//Left
					-0.5, -0.5, 0.5, 0.0, 0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0,
					-0.5, 0.5, 0.5, 0.0, 0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0,
					-0.5, 0.5, -0.5, 0.0, 0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0,

					-0.5, -0.5, -0.5, 0.0, 0.0, 0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0,//bottom
						0.5, -0.5, -0.5, 0.0, 0.0, 0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0,
						0.5, -0.5, 0.5, 0.0, 0.0, 0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0,
					-0.5, -0.5, 0.5, 0.0, 0.0, 0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0,

						0.5, -0.5, -0.5, 0.0, 0.0, 0.0, 0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 1.0, 0.0,//back
					-0.5, -0.5, -0.5, 0.0, 0.0, 0.0, 0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, -1.0, 0.0, 0.0, 0.0, 1.0, 0.0,
					-0.5, 0.5, -0.5, 0.0, 0.0, 0.0, 0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0, -1.0, 0.0, 0.0, 0.0, 1.0, 0.0,
						0.5, 0.5, -0.5, 0.0, 0.0, 0.0, 0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, -1.0, 0.0, 0.0, 0.0, 1.0, 0.0


					],
					//the mainTexture defines where the color is displayed with alpha 0.0 (when in mode 1)
					//These are built with X- being the front main surface, Y- being the bottom and Z- being the left so defalut corners will
					//be for the bottom left, furthest from the camera, Default edges will be left bottom, 
					//Defalut centers will be left, The models will be on a base 1 basis where each Cubie is 1.0 by 1.0 by 1.0 large. 
					//Cubies will range from -0.5 to 0.5 for the main part of the cubie for fitting with other parts of the cube. 
					//Extra parts such as connectors may be added beyond this limit but will not change how the size of the cube is treated
					//Cube will be automaticaly scaled using a scaling Matrix to fit the users screen best.
					centerLocations: [{ color: [3, 25, 47, 69], id_color: [9, 31, 53, 75] }],
					edgeLocations: [{ color: [3, 25, 47, 69], id_color: [9, 31, 53, 75] }, { color: [91, 113, 135, 157], id_color: [97, 119, 141, 163] }],
					cornerLocations: [{ color: [3, 25, 47, 69], id_color: [9, 31, 53, 75] }, { color: [91, 113, 135, 157], id_color: [97, 119, 141, 163] }, { color: [179, 201, 223, 245], id_color: [185, 207, 229, 251] }],//these are used to find the locations for the color and id_color inputs for each side to do a sub buffer when the colors need an update. [color:[start of color index], id_color:[19,23,ect.]]     Up to 3 color indexes are made depending on the colors the part needs 

					centerFaces: [[0, 1, 2, 0, 2, 3], [0, 6, 0, 0], null],
					edgeFaces: [[0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7], [0, 6, 6, 6, 0, 0], null],
					cornerFaces: [[0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11], [0, 6, 6, 6, 12, 6, 0, 0], null]//separeated as to help with selecting a side to hilight when hovered over
					//New, E buffers (Faces) are now stored in 1 buffer that is shared among ALL CUBIES of the same type and style. This will cut down memory and and more importantly, drop the number of required uploads to buffers.
					//so instead of [[face1],[face2],[face3],[body]] it will go [[face1,face2,face3,body],[face1Start,face1length....],buffer]	
					//the cube can be broken into 4 parts, 1 for each color (3), and then another part that is not tied to a color but still renders as part of the piece. (in the current model, this is nothing)
				}]

		};
		var Algorithm = {
			//This Library depends on the CubeData object for editing algorithm data and cubes.
			/* About Algorithms
				Moves are depicted by two parts, a way to identify a layer, and a direction
				A layer means any turnable layer on the cube, starting with left to right, then bottom to top, then back to front
				A direction refers to how that layer is turned, so 90 CW, 180 CW (or CCW, doesn't mater), and 90 CCW
				When on an odd Cube (3,5,ect.) layers are numbered starting as listed above (L to R), skipping the middel layer so the left layer is layer 0 and the right layer is layer 1 (on a 3 by 3)
				When on an even Cube all alyers are numbered, not skipping any, so on a 4 by 4 the left layer is 0 while the right layer is 3.
				When a move is stored in an uncompressed format, it simply goes [layer,direction] and can be stuck together with other moves to make up an algorithm
				When a move is stored in a compressed format, the move is stored as layer * direction. Bit length is determined by the next POT above or at (totalLayers*3)
			*/
			CacheResolution: 100,
			TotalAlgorithms: [],//3,5,816480 number of algorithms given for a 3 by 3 Cube; The totals are calculated by running the the algorithm finding code, stored as [cubeSize, AlgLength, NumOfAlgs]
			Cache: [],//this will be an array that stores algorithms periodicaly to help save time when finding large number algoithms. stored as [cubeSize,AlgLength,Uint8Array(totalAlgorithms data),bitLength]
			Que: [3, 5, 3, 4, 3, 3, 3, 2, 3, 1],//stores the algorithms in a to do list so if it is called again for some reason, it will not fight with an ongoing process.
			moves: null,//an array that stores the current system of moves, uncompressed. format [layer,direction]
			done: false,
			setup: false,
			newMove: true,// this means the previous move was just set up and this is a new move for the current depth. Indicates that the depth (if not already at the max) should be incremented
			depth: 0,//the current depth is used to check for solutions
			maxDepth: 0,
			hasLeft: false,
			cubeCount: 0,
			cubeSize: 0,
			movesPerRun: 1000000,//the maximum amount of times that the IndexRun should run per frame, allows for this event to be async.
			time: 0,
			oldTime: 0,
			newTime: 0,
			running: false,
			gMoves: [],//these copies of variables are for making the get algorithm function more efficeint, espicialy when running sequentialy.
			gDepth: 0,
			gMaxDepth: 0,
			gNewMove: 0,
			gCount: -1,
			gCubeSize: 0,
			gSetup: false,
			gShouldCount: false,
			lastCount: -1,
			UncompressedAlgorithms: [],//an array that temporaily holds the data for algorithms that will later be compressed into a nice Uint8 Array.
			SavedFilters: [],//saved like this [cubeSize,format,MovesPerFilter,filterArray,...]
			AlgIndex(size, depth) {
				var shouldQue = true;
				for (var i = 0; i < Algorithm.Cache.length; i += 4) {
					if (Algorithm.Cache[i] == size && Algorithm.Cache[i + 1] == depth) {//make sure we havent already cached the results.
						console.log("Algorithm already cached");
						return;
					}
				}
				for (var i = 0; i < Algorithm.Que.length; i += 2) {
					if (Algorithm.Que[i] == size && Algorithm.Que[i + 1] == depth) {//make sure we havent already cached the results.
						console.log("Algorithm already qued");
						shouldQue = false;
						break;
					}
				}
				if (shouldQue)
					Algorithm.Que.push(size, depth);
				if (!Algorithm.running) {
					Algorithm.BeginRun();
				}
			},
			FinishRun() {

				var layerCount = Algorithm.CountLayers(this.cubeSize);
				var maxValue = layerCount * 3;
				var POT = CubeData.CalculateBitLength(maxValue);
				var MovesArray = new Uint8Array(Math.ceil((POT * Algorithm.UncompressedAlgorithms.length * Algorithm.Que[1]) / 8));
				for (var i = 0; i < Algorithm.UncompressedAlgorithms.length; i++) {
					for (var j = 0; j < Algorithm.Que[1]; j++) {
						CubeData.ChangeBinaryData(MovesArray, j * POT + i * POT * Algorithm.Que[1], Algorithm.UncompressedAlgorithms[i][j * 2] + Algorithm.UncompressedAlgorithms[i][j * 2 + 1] * layerCount, POT);
					}
				}

				Algorithm.Que.splice(0, 2);//remove the items from the que.

				Algorithm.Cache.push(Algorithm.cubeSize, Algorithm.maxDepth, MovesArray, POT);
				Algorithm.TotalAlgorithms.push(Algorithm.cubeSize, Algorithm.maxDepth, Algorithm.cubeCount);
			},
			BeginRun() {
				Algorithm.moves = new Array(Algorithm.Que[1] * 2),//an array that stores the current system of moves, uncompressed. format [layer,direction]
					Algorithm.done = false,
					Algorithm.newMove = true,
					Algorithm.setup = false,
					Algorithm.depth = 0,
					Algorithm.maxDepth = Algorithm.Que[1],
					Algorithm.hasLeft = false,
					Algorithm.cubeCount = 0,
					Algorithm.cubeSize = Algorithm.Que[0],
					Algorithm.UncompressedAlgorithms = [],
					Algorithm.running = true;
				for (var i = 0; i < Algorithm.moves.length; i++) {
					Algorithm.moves[i] = 0;
				}
				for (var i = 0; i < Algorithm.Cache.length; i += 4) {
					if (Algorithm.Cache[i] == Algorithm.cubeSize && Algorithm.Cache[i + 1] == Algorithm.maxDepth) {//make sure we havent already cached the results.
						Algorithm.running = false;
						console.log("Algorithm already cached");
					}
				}
				if (Algorithm.running)
					Algorithm.Indexer();

			},
			CountLayers(size) {
				if (size <= 1 && size % 1 === 0)//checks for negative numbers and non integers.
					return 0;

				return (size % 2 === 1) ? (size - 1) * 3 : (size * 3);//checks if size is odd or even and returns correct value for the size.
			},
			MovesToText(moves, cubeSize, moveCount, compressed = true) {
				//TODO
				var POT = CubeData.CalculateBitLength(Algorithm.CountLayers(cubeSize) * 3);
				var key = [];
				var base = ['L', 'R', 'D', 'U', 'B', 'F', '', "'", '2', ", "];
				var result = "";
				var layerCount = Algorithm.CountLayers(cubeSize);
				var isEven = (cubeSize % 2 == 0);
				var layersPerFace = layerCount / 6;
				// debugger;
				for (var i = 0; i < layerCount * 3; i++) {
					var face = Math.floor(i % layerCount / layersPerFace);
					var number = i % layerCount % layersPerFace + 1;
					var direction = Math.floor(i / layerCount);
					var shouldReverse = false;
					if (face == 1 || face == 3 || face == 5)
						shouldReverse = true;
					if (shouldReverse)
						number = layersPerFace - i % layerCount % layersPerFace;

					var total = "";
					if (number > 1) {
						total += number;
					}
					total += base[face];
					if ((shouldReverse && direction == 0) || (!shouldReverse && direction == 2)) {
						total += base[7];
					} else if (direction == 1) {
						total += base[8];

					} else {
						total += base[6];
					}

					key.push(total);


				}

				for (var i = 0; i < moveCount; i++) {
					var move = 0;


					if (compressed)
						move = CubeData.PullInfo(moves, i, POT);
					else
						move = moves[i];

					result += key[move];
					if (!(i + 1 >= moveCount)) {
						result += base[9]
					}

				}
				return result;
			},
			Indexer() {
				for (var a = 0; a < Algorithm.movesPerRun; a++) {
					if (Algorithm.moves[0] != 0) {
						Algorithm.hasLeft = true;
					}
					if ((Algorithm.hasLeft && Algorithm.moves[0] == 0) || !Algorithm.running) {
						break;//the code is complete
					}
					Algorithm.IndexRun();
				}
				if (!(Algorithm.hasLeft && Algorithm.moves[0] == 0) && Algorithm.running) {
					requestAnimationFrame(Algorithm.Indexer);

				} else {
					Algorithm.running = false;
					Algorithm.FinishRun();

					if (Algorithm.Que.length > 0) {
						Algorithm.BeginRun();
					}
				}
			},
			IndexRun() {
				if (!Algorithm.setup) {
					Algorithm.setup = true;//Posible Optimization, remove this, I am not sure why it was needed in the first place
					// Algorithm.depth++;
				} else {
					if (Algorithm.newMove) {
						Algorithm.moves[Algorithm.depth * 2] = 0;
						Algorithm.moves[Algorithm.depth * 2 + 1] = 0;
						var timesRun = 0;
						while (!Algorithm.CheckValidMove(Algorithm.moves[Algorithm.depth * 2], Algorithm.cubeSize, Algorithm.depth, Algorithm.moves) && timesRun < Algorithm.CountLayers(Algorithm.cubeSize)) {
							Algorithm.moves[Algorithm.depth * 2]++;
							timesRun++;
						}
						if (Algorithm.depth + 1 <= Algorithm.maxDepth - 1) {
							Algorithm.depth++;
							Algorithm.newMove = true;
						} else {
							Algorithm.newMove = false;
							/*if(Algorithm.cubeCount % Algorithm.CacheResolution === 0)
							 Algorithm.UncompressedAlgorithms.push(Algorithm.moves.slice(0));
							 if(Algorithm.maxDepth == 1)
									 console.log(Algorithm.moves.slice(0));
							 Algorithm.cubeCount++;*/

						}

					} else {

						if (Algorithm.depth == Algorithm.maxDepth - 1) {
							if (Algorithm.cubeCount % Algorithm.CacheResolution === 0)
								Algorithm.UncompressedAlgorithms.push(Algorithm.moves.slice(0));

							Algorithm.cubeCount++;
						}


						Algorithm.moves[Algorithm.depth * 2 + 1]++;

						if (Algorithm.moves[Algorithm.depth * 2 + 1] > 2) {

							Algorithm.moves[Algorithm.depth * 2 + 1] = 0;
							Algorithm.moves[Algorithm.depth * 2]++;
							var timesRun = 0;
							while (!Algorithm.CheckValidMove(Algorithm.moves[Algorithm.depth * 2], Algorithm.cubeSize, Algorithm.depth, Algorithm.moves) && timesRun < Algorithm.CountLayers(Algorithm.cubeSize)) {
								Algorithm.moves[Algorithm.depth * 2]++;
								timesRun++;
							}
							if (Algorithm.moves[Algorithm.depth * 2] >= Algorithm.CountLayers(Algorithm.cubeSize)) {
								if (Algorithm.depth > 0) {
									Algorithm.depth--;
								} else {
									console.log("done");
									Algorithm.running = false;
								}
							} else {

								if (Algorithm.depth + 1 <= Algorithm.maxDepth - 1) {
									Algorithm.depth++;

									Algorithm.newMove = true;
								} else {

								}
							}
						} else if (Algorithm.depth + 1 <= Algorithm.maxDepth - 1) {
							Algorithm.depth++;
							Algorithm.newMove = true;
						} else {
							/*if(Algorithm.cubeCount % Algorithm.CacheResolution === 0)
								Algorithm.UncompressedAlgorithms.push(Algorithm.moves.slice(0));
							if(Algorithm.maxDepth == 1)
								console.log(Algorithm.moves.slice(0));
							Algorithm.cubeCount++;*/
						}
					}

				}

			},
			CheckValidMove(layer, size, depth, moves) {
				//disallows working on the same layer as the last move
				//disallows working on a layer that has not been affected by the last move.
				//scans all previous moves to see if the above layer has been affected by other moves, if it has not, then this
				// cube is already present in another branch and should no longer be continued on this branch.
				//Checks for algs that are interchangible such as RL and LR and will only do the first one that occurs (saves about 30%)
				var isValid = true;
				var isOdd = (size % 2 == 0) ? false : true;

				var layerCount = isOdd ? (size - 1) : size;

				if ((layer >= (size - 1) * 3 && isOdd) || (layer >= size * 3 && !isOdd) || layer < 0) {//checks layer is valid

					return false;
				}
				var parallelLayers = [];//these are the only layers that can be moved without affecting the previous layers
				var direction = Math.floor(layer / layerCount);//aka plane

				for (var i = 0; i < layerCount; i++) {
					if (i + layerCount * direction != layer) {
						parallelLayers.push(i + layerCount * direction);
					}
				}

				var cont = true;
				for (var i = depth - 1; i >= 0 && cont; i--) {
					cont = false;
					if (moves[i * 2] == layer) {
						isValid = false;
						break;
					} else if (parallelLayers.includes(moves[i * 2])) {
						if (moves[i * 2] < layer) {//checks for interchagible algs and will invalidate High to Low layer movement so LR is valid but RL is not(saves)
							cont = true;
						} else {
							isValid = false;
							break;
						}// this allows the previous move to be checked (if it exists) as the parallel layer does not affect the next layer so
						//the previous moves need to be checked to see if they affect the layer
					}
				}

				return isValid;
			},
			GetAlgorithm(cubeSize, AlgLength, AlgNumber, compressed) {
				var isCreated = false;
				var cacheIndex = 0;
				for (var i = 0; i * 4 < Algorithm.Cache.length; i++) {
					if (Algorithm.Cache[i * 4] === cubeSize && Algorithm.Cache[i * 4 + 1] === AlgLength) {
						isCreated = true;
						cacheIndex = i;
						break;
					}
				}

				if (isCreated) {
					var distanceInCache = AlgNumber % Algorithm.CacheResolution;
					var distanceFromLast = AlgNumber - Algorithm.gCount;//Find out where to start finding the algorithm from, distanceFromLast refers to the last time an algorithm was found and
					//distanceInCache refers to the closest algorithm stored in the cache as some were removed to preserve space.
					if (AlgLength === Algorithm.gMaxDepth && cubeSize === Algorithm.gCubeSize && (distanceFromLast < distanceInCache && distanceFromLast >= 0)) {
						//use settings already in memory
						Algorithm.RunTo(AlgNumber);
					} else {
						//pull move state from cache
						//var algStride = AlgLength * Algorithm.Cache[cacheIndex*4+3];
						var algIndex = Math.floor(AlgNumber / Algorithm.CacheResolution);
						var layerCount = Algorithm.CountLayers(cubeSize);
						//var algStart = algStride * algIndex;//in bits
						Algorithm.gCubeSize = cubeSize;
						Algorithm.gMaxDepth = AlgLength;
						Algorithm.gDepth = AlgLength - 1;
						Algorithm.gSetup = true;
						Algorithm.gShouldCount = false;
						Algorithm.gNewMove = false;
						Algorithm.gMoves = [];
						Algorithm.gCount = Math.floor(AlgNumber / Algorithm.CacheResolution) * Algorithm.CacheResolution;
						for (var i = 0; i < AlgLength; i++) {
							var num = CubeData.PullInfo(Algorithm.Cache[cacheIndex * 4 + 2], algIndex * AlgLength + i, Algorithm.Cache[cacheIndex * 4 + 3]);
							var layer = num % layerCount;
							var direction = Math.floor(num / layerCount);
							Algorithm.gMoves.push(layer, direction);

						}

						Algorithm.RunTo(AlgNumber);

					}
					if (compressed) {
						var alg = new Uint8Array(Math.ceil(Algorithm.Cache[cacheIndex * 4 + 3] * AlgLength / 8));


						for (var i = 0; i < AlgLength; i++) {

							CubeData.ChangeBinaryData(alg, i * Algorithm.Cache[cacheIndex * 4 + 3], Algorithm.gMoves[i * 2] + Algorithm.gMoves[i * 2 + 1] * Algorithm.CountLayers(Algorithm.gCubeSize), Algorithm.Cache[cacheIndex * 4 + 3])
						}
						return alg;
					} else {
						return Algorithm.gMoves;
					}
				} else {
					return null;
				}
			},
			RunTo(AlgNumber) {

				function IndexRun(algNumber) {
					if (!Algorithm.gSetup) {
						Algorithm.gSetup = true;
						Algorithm.gDepth++;
					} else {
						if (Algorithm.gNewMove) {
							Algorithm.gMoves[Algorithm.gDepth * 2] = 0;
							Algorithm.gMoves[Algorithm.gDepth * 2 + 1] = 0;
							var timesRun = 0;
							while (!Algorithm.CheckValidMove(Algorithm.gMoves[Algorithm.gDepth * 2], Algorithm.gCubeSize, Algorithm.gDepth, Algorithm.gMoves) && timesRun < Algorithm.CountLayers(Algorithm.gCubeSize)) {
								Algorithm.gMoves[Algorithm.gDepth * 2]++;
								timesRun++;
							}
							if (Algorithm.gDepth + 1 <= Algorithm.gMaxDepth - 1) {//have we hit bottom?
								Algorithm.gDepth++;     //if not go down
								Algorithm.gNewMove = true;
							} else {
								Algorithm.gNewMove = false;//else explore
								Algorithm.gCount++;
							}

						} else {


							//if(Algorithm.gCount != AlgNumber)

							Algorithm.gMoves[Algorithm.gDepth * 2 + 1]++;

							if (Algorithm.gMoves[Algorithm.gDepth * 2 + 1] > 2) {

								Algorithm.gMoves[Algorithm.gDepth * 2 + 1] = 0;
								Algorithm.gMoves[Algorithm.gDepth * 2]++;
								var timesRun = 0;
								while (!Algorithm.CheckValidMove(Algorithm.gMoves[Algorithm.gDepth * 2], Algorithm.gCubeSize, Algorithm.gDepth, Algorithm.gMoves) && timesRun < Algorithm.CountLayers(Algorithm.gCubeSize)) {
									Algorithm.gMoves[Algorithm.gDepth * 2]++;
									timesRun++;
								}
								if (Algorithm.gMoves[Algorithm.gDepth * 2] >= Algorithm.CountLayers(Algorithm.gCubeSize)) {//go over layer count
									if (Algorithm.gDepth > 0) {
										Algorithm.gDepth--;//go up
									} else {
										Algorithm.gMoves[0] = 0;
										Algorithm.gMoves[1] = 0;//reset
									}

								} else {

									if (Algorithm.gDepth + 1 <= Algorithm.gMaxDepth - 1) {//go down
										Algorithm.gDepth++;

										Algorithm.gNewMove = true;
									}
								}
							} else if (Algorithm.gDepth + 1 <= Algorithm.gMaxDepth - 1 && Algorithm.gCount != AlgNumber) {//Are we at the bottom?
								Algorithm.gDepth++;//go down
								Algorithm.gNewMove = true;
							} else {
								Algorithm.gCount++;
							}
						}

					}

				}
				while (Algorithm.gCount != AlgNumber) {
					IndexRun(AlgNumber);
				}
			},
			TurnCube(data, cube = 0, format, cubeSize, moves, moveCount = 1, shouldEdit = true, compressed = true, movesPerMove = 1) {
				//Accepts moves in compressed format and does them to the cube
				//should Edit states wether or not the original data should remain the same
				//if false, the new cube is just returned, if true, the data is updated to the new cube as well

				//turns can be simplified into pieces that are swapped and transformed, using a lot of the cubeData utilities made previously, this should not be a hard task.
				var ftu = -1;//filter to use
				for (var i = 0; i < Algorithm.SavedFilters.length; i += 4) {//check for the filters we need for the moves we are doing, if they are not already built, build them.
					if (Algorithm.SavedFilters[i] == cubeSize && Algorithm.SavedFilters[i + 1] == format && Algorithm.SavedFilters[i + 2] == movesPerMove) {
						ftu = i + 3;
						break;
					}
				}
				if (ftu == -1) {
					Algorithm.SavedFilters.push(cubeSize, format, movesPerMove, Algorithm.BuildFilters(cubeSize, format));
					ftu = Algorithm.SavedFilters.length - 1;
				}
				var originCube;
				var destinationCube;
				if (moves.length > 0) {
					var move;

					var POT = CubeData.CalculateBitLength(Algorithm.CountLayers(cubeSize) * 3);
					originCube = CubeData.PullCube(data, format, cube, cubeSize);
					destinationCube = CubeData.Copy(originCube);
					for (var i = 0; i < moveCount; i++) {
						if (compressed)
							move = CubeData.PullInfo(moves, i, POT);
						else
							move = moves[i];
						var filterLength = Algorithm.SavedFilters[ftu][move].length;
						switch (format) {
							case (CubeDataType.Surface): {
								for (var j = 0; j < filterLength; j++) {
									CubeData.Change(destinationCube, format, 0, j, cubeSize, CubeData.PullInfo(originCube, Algorithm.SavedFilters[ftu][move][j], 3))
								}
								originCube = CubeData.Copy(destinationCube);
								break;
							}
							case (CubeDataType.Piece): {
								var LocationCount = cubeSize * cubeSize * cubeSize - (cubeSize - 2) * (cubeSize - 2) * (cubeSize - 2);
								for (var j = 0; j < filterLength; j++) {
									var originLocation = Algorithm.SavedFilters[ftu][move][j];
									var homeChange = Math.floor(originLocation / LocationCount);
									originLocation %= LocationCount;
									var xyz = CubeData.GetPieceCoords(j, cubeSize);
									var PieceCodeCount = CubeData.CountSides(xyz[0], xyz[1], xyz[2], cubeSize) == 3 ? 8 : 12;//helps get the home range correct
									// it doesn't care for center pieces as their home should be 0 anyways
									var dataEntry = ((CubeData.PullInfo(originCube, originLocation, 5) + homeChange * PieceCodeCount) % 24)
									CubeData.Change(destinationCube, format, 0, j, cubeSize, dataEntry);
								}
								originCube = CubeData.Copy(destinationCube);
								break;
							}
							case (CubeDataType.Compact): {
								for (var j = 0; j < filterLength; j++) {
									CubeData.Change(destinationCube, format, 0, j, cubeSize, CubeData.PullInfo(originCube, Algorithm.SavedFilters[ftu][move][j], 3))
								}
								originCube = CubeData.Copy(destinationCube);
								break;
							}
							case (CubeDataType.Fast): {
								for (var j = 0; j < filterLength; j++) {
									destinationCube[j] = originCube[Algorithm.SavedFilters[ftu][move][j]];
								}
								originCube = CubeData.Copy(destinationCube);
								break;
							}
						}
					}
					if (shouldEdit) {
						CubeData.PasteCube(data, format, originCube, cube, cubeSize);
					}
					return originCube;//it doesn't mater if we use origin or destination as at this point they should be the same
				}
			},
			GetAllMoves(size) {
				var numberOfMoves = Algorithm.CountLayers(size) * 3;
				var POT = CubeData.CalculateBitLength(numberOfMoves);
				var MovesArray = new Uint8Array(Math.ceil((POT * numberOfMoves) / 8));
				for (var i = 0; i < numberOfMoves; i++) {
					CubeData.ChangeBinaryData(MovesArray, i * POT, i, POT);
				}
				return MovesArray;
			},
			GetNumberOfMoves(size) {
				var numberOfMoves = Algorithm.CountLayers(size) * 3;
				return numberOfMoves;
			},
			BuildFilters(size = 3, format = 0, moves = A2.GetAllMoves(size), numberOfMoves = A2.GetNumberOfMoves(size), moveLength = 1) {
				/*
				size: the size of cube the filter is being built for
				format: the format of cube the filter is being built for
				moves (optional): the moves in(in groups of moveLength) in the compressed to have filters created for, default is all moves for a specified cube
				moveLength (optional): since only 1 Uint8Array is passed with the moves, this tells how to group the moves together. Default is 1 (each move generates its own filter).
				an example use of moveLength is when I have a bunch of 2 move algorithms to be changed to filters.
				*/
				//TODO finish building filters for piece type and compact type cubes
				/*About Filters: Filters are basicaly a special type of cube that is nearly equal to a solved cube but with the specified move(s) applied. 
				The purpose of a filter is to avoid having to do calculations to how a cube moves, instead it just says, the piece in location 4 ends up at location 8. 
				Filters are Uint32 arrays (as that should support all numbers that a piece can currently be in multiplied by 3) where each number in the array describes
				where and how a piece moves when the move is applied. To find out where a piece (or surface) moves, simply do Number%numberOfLocations, to find out how the the home value changes do 
				Math.floor(Number/numberOfLocations), add the result to the home value of the piece (and then mod it to be in the correct range).
		
				*/
				/*
				Building Filters:
				First 2 default filters are created, which generates no changes. 
				Then the data in the second filter pulls data from the first when it is being operated on with one move
				The second filter is coppied to the first filter and then the process repeats for each move in the move sequence
				Then the second filter is saved as the result and the next filter begins being built.
		
				the array of filters is then returned.
				*/
				//debugger;
				var builtFilters = [];
				var pMoves = Algorithm.CountLayers(size) * 3;
				var POT = CubeData.CalculateBitLength(pMoves);
				//var numberOfMoves = Math.floor((moves.length * 8)/(POT));
				var numberOfLocations = CubeData.GetAmountOfData(size, format);
				var originFilter;
				var destinationFilter;
				var layer;
				var direction;
				var isOdd = (size % 2 == 1);
				var plane = 0;//0 is a slice of x, 1 is a slice of y, 2 is a slice of z
				var planeLocation = 0;//tells which slice of cube you are on.
				var offset = 0;

				function resetFilters() {
					originFilter = new Float32Array(numberOfLocations);//must do this to avoid storing the same Float32Array Object
					destinationFilter = new Float32Array(numberOfLocations);
					for (var i = 0; i < numberOfLocations; i++) {
						destinationFilter[i] = i;
					}
				}
				function copyDestinationToOrigin() {
					for (var i = 0; i < numberOfLocations; i++) {
						originFilter[i] = destinationFilter[i];

					}
				}
				for (var i = 0; i < numberOfMoves; i += moveLength) {
					resetFilters();
					var j = 0;
					do {
						layer = CubeData.PullInfo(moves, i + j, POT);
						direction = Math.floor(layer / Algorithm.CountLayers(size));//add one to this to see how many times a rotation should be done
						layer %= Algorithm.CountLayers(size);

						if (isOdd) {
							plane = Math.floor(layer / (size - 1));
							planeLocation = layer % (size - 1);
							if (planeLocation + 1 > size / 2) {//because odd cubes should not have their center turned
								planeLocation++;
							}
						} else {
							plane = Math.floor(layer / size);
							planeLocation = layer % size;
						}
						var k = 0;
						switch (format) {
							case (CubeDataType.Fast)://Fallthrough
							case (CubeDataType.Surface): {
								switch (plane) {
									case (0): {//a slice of X


										for (var l = 0; l < direction + 1; l++) {
											copyDestinationToOrigin();
											offset = size * size + (size * 4) * planeLocation;
											//equation for bottom: offset + size - 1 - c;
											//equation for back: offset + size + c*2;
											//equation for top: offset + size * 3 + c;
											//equation for front: offset + size + (size-c-1)*2 + 1
											for (var c = 0; c < size; c++) {
										/*bot to bac*/destinationFilter[offset + size + c * 2] = originFilter[offset + size - 1 - c];
										/*bac to top*/destinationFilter[offset + size * 3 + c] = originFilter[offset + size + c * 2];
										/*top to frt*/destinationFilter[offset + size + (size - c - 1) * 2 + 1] = originFilter[offset + size * 3 + c];
										/*frt to bot*/destinationFilter[offset + size - 1 - c] = originFilter[offset + size + (size - c - 1) * 2 + 1];
											}
											if (planeLocation == 0 || planeLocation == size - 1) {//on left side
												//equation 1 = c;
												//equation 2 = (size-1-(c % size))*size+Math.floor(c/size);
												if (planeLocation == 0) {
													offset = 0;
												}
												else {
													offset = size * size + (4 * size) * size;
												}
												for (var c = 0; c < size * size; c++) {
													destinationFilter[offset + (size - 1 - (c % size)) * size + Math.floor(c / size)] = originFilter[offset + c];
												}
											}

										}
										break;
									}
									case (1): {//a slice of y

										//offset = planeLocation * size;//elevates on left side
										for (var l = 0; l < direction + 1; l++) {
											copyDestinationToOrigin();
											//equation for left: c + planeLocation*size;
											//equation for back: (size-1-c)*(size*4)+size*size+size+planeLocation*2;
											//equation for right:(size-1-c) + size*size+(size*4)*size + planeLocation*size;
											//equation for front: c*(size*4)+size*size+size+planeLocation*2+1;
											for (var c = 0; c < size; c++) {
										/*frt to rig*/destinationFilter[(size - 1 - c) + size * size + (size * 4) * size + planeLocation * size] = originFilter[c * (size * 4) + size * size + size + planeLocation * 2 + 1];
										/*rig to bac*/destinationFilter[(size - 1 - c) * (size * 4) + size * size + size + planeLocation * 2] = originFilter[(size - 1 - c) + size * size + (size * 4) * size + planeLocation * size];
										/*bac to lef*/destinationFilter[c + planeLocation * size] = originFilter[(size - 1 - c) * (size * 4) + size * size + size + planeLocation * 2];
										/*lef to frt*/destinationFilter[c * (size * 4) + size * size + size + planeLocation * 2 + 1] = originFilter[c + planeLocation * size];
											}
											if (planeLocation == 0 || planeLocation == size - 1) {
												//equation 1 = offset + (c % size) + Math.floor(c/size)*(size*4);
												//equation 2 = offset + (c % size)*(size*4)+(size-1-Math.floor(c/size));
												if (planeLocation == 0) {
													offset = size * size;
												}
												else {
													offset = size * size + size * 3;
												}
												for (var c = 0; c < size * size; c++) {
													destinationFilter[offset + (c % size) * (size * 4) + (size - 1 - Math.floor(c / size))] = originFilter[offset + (c % size) + Math.floor(c / size) * (size * 4)];
												}
											}

										}
										break;
									}
									case (2): {//a slice of z

										offset = planeLocation * size;//elevates on left side
										for (var l = 0; l < direction + 1; l++) {
											copyDestinationToOrigin();
											//equation for left:(size-1-c)*size+planeLocation;
											//equation for top: (size-1-c)*(size*4)+planeLocation + size*3 + size*size;
											//equation for right:c*size+size*size + size*(size*4)+planeLocation;
											//equation for bottom: c*(size*4)+planeLocation + size*size;
											for (var c = 0; c < size; c++) {
										/*top to lef*/destinationFilter[(size - 1 - c) * size + planeLocation] = originFilter[(size - 1 - c) * (size * 4) + planeLocation + size * 3 + size * size];
										/*lef to bot*/destinationFilter[c * (size * 4) + planeLocation + size * size] = originFilter[(size - 1 - c) * size + planeLocation];
										/*bot to rig*/destinationFilter[c * size + size * size + size * (size * 4) + planeLocation] = originFilter[c * (size * 4) + planeLocation + size * size];
										/*rig to top*/destinationFilter[(size - 1 - c) * (size * 4) + planeLocation + size * 3 + size * size] = originFilter[c * size + size * size + size * (size * 4) + planeLocation];
											}
											if (planeLocation == 0 || planeLocation == size - 1) {
												//equation 1 = offset + (c % size)*(size*4)  + Math.floor(c/size)*2;
												//equation 2 = offset + (c % size)*2  + (size-1-Math.floor(c/size))*size*4;
												if (planeLocation == 0) {
													offset = size * size + size;
												}
												else {
													offset = size * size + size + 1;
												}
												for (var c = 0; c < size * size; c++) {
													destinationFilter[offset + (c % size) * 2 + (size - 1 - Math.floor(c / size)) * size * 4] = originFilter[offset + (c % size) * (size * 4) + Math.floor(c / size) * 2];
												}
											}

										}
									}
										break;

								}
								break;
							}
							case (CubeDataType.Piece): {
								//Notes: to add a home value, you need to add the number of locations mult by the home value change to have the turner update the cube properly.
								// Home change can go above 2 as the final value saved in data will be corrected to be in the right range. However it is nice to have the values
								//in the range they should be to begin with
								switch (plane) {
									case (0): {
										for (var l = 0; l < direction + 1; l++) {
											copyDestinationToOrigin();

											if (planeLocation == 0) {
												for (var c = 0; c < size * size; c++) {//left side
													destinationFilter[(size - 1 - (c % size)) * size + Math.floor(c / size)] = originFilter[c];
												}

											} else if (planeLocation == size - 1) {
												offset = size * size + (size - 2) * (2 * size + (size - 2) * 2);
												//       ^Left side    ^V layer  ^top and Bottom layers and then all remaining centers on front and back
												for (var c = 0; c < size * size; c++) {//right side
													if (c == size - 1)
														destinationFilter[offset + (size - 1 - (c % size)) * size + Math.floor(c / size)] = (originFilter[offset + c] + numberOfLocations) % (numberOfLocations * 3);//Special case for right bottom back corner
													else
														destinationFilter[offset + (size - 1 - (c % size)) * size + Math.floor(c / size)] = ((c == size * (size - 1)) ? originFilter[offset + c] + numberOfLocations * 2 : originFilter[offset + c]) % (numberOfLocations * 3);
												}
											} else {
												offset = size * size + (planeLocation - 1) * (2 * size + (size - 2) * 2);
												for (var c = 0; c < size - 2; c++) {//centers that are perp to the plane
										/*bot to bac*/destinationFilter[offset + size + c * 2] = originFilter[offset + 1 + (size - 3 - c)];
										/*bac to top*/destinationFilter[offset + size + (size - 2) * 2 + 1 + c] = originFilter[offset + size + c * 2];
										/*top to frt*/destinationFilter[offset + size + 1 + (size - 3 - c) * 2] = originFilter[offset + size + (size - 2) * 2 + 1 + c];
										/*frt to bot*/destinationFilter[offset + 1 + (size - 3 - c)] = originFilter[offset + size + 1 + (size - 3 - c) * 2];
												}
												//edges
												destinationFilter[offset] = (originFilter[offset + size - 1] + numberOfLocations) % (numberOfLocations * 2);
												destinationFilter[offset + 2 * (size - 2) + size] = originFilter[offset];
												destinationFilter[offset + 2 * (size - 2) + size * 2 - 1] = (originFilter[offset + 2 * (size - 2) + size] + numberOfLocations) % (numberOfLocations * 2);
												destinationFilter[offset + size - 1] = originFilter[offset + 2 * (size - 2) + size * 2 - 1];

											}

										}
										break;
									}
									case (1): {
										for (var l = 0; l < direction + 1; l++) {
											copyDestinationToOrigin();

											var layerJump = (size - 1) * 4;
											if (planeLocation == 0) {
												for (var c = 0; c < size - 2; c++) {//bottom side centers & edges
													//centers
													var offSet = size * size + 1;
													for (var d = 0; d < size - 2; d++) {
														destinationFilter[offSet + d * layerJump + (size - 3 - c)] = originFilter[offSet + c * layerJump + d];
													}
											//edges
											/*LD to DF*/destinationFilter[size * size + size - 1 + c * layerJump] = (originFilter[1 + c] + numberOfLocations) % (numberOfLocations * 2);
											/*DF to RD*/destinationFilter[size * size + layerJump * (size - 2) + size - 2 - c] = originFilter[size * size + size - 1 + c * layerJump];
											/*RD to DB*/destinationFilter[size * size + (size - 3 - c) * layerJump] = originFilter[size * size + layerJump * (size - 2) + size - 2 - c];
											/*DB to LD*/destinationFilter[1 + c] = (originFilter[size * size + (size - 3 - c) * layerJump] + numberOfLocations) % (numberOfLocations * 2);

												}
										//corners
										/*RDB to LDB*/destinationFilter[0] = (originFilter[size * size + layerJump * (size - 2)] + numberOfLocations * 2) % (numberOfLocations * 3);
										/*LDB to LDF*/destinationFilter[size - 1] = (originFilter[0] + numberOfLocations * 2) % (numberOfLocations * 3);
										/*LDF to RDF*/destinationFilter[size * size + layerJump * (size - 2) + size - 1] = (originFilter[size - 1] + numberOfLocations * 2) % (numberOfLocations * 3);
										/*RDF to RDB*/destinationFilter[size * size + layerJump * (size - 2)] = originFilter[size * size + layerJump * (size - 2) + size - 1];


											} else if (planeLocation == size - 1) {
												for (var c = 0; c < size - 2; c++) {//bottom side centers & edges
													//centers
													var offSet = size * size + 3 + 3 * (size - 2);
													for (var d = 0; d < size - 2; d++) {
														destinationFilter[offSet + d * layerJump + (size - 3 - c)] = originFilter[offSet + c * layerJump + d];
													}
											//edges
											/*LU to UF*/destinationFilter[size * size + (size - 2) * 4 + 3 + c * layerJump] = originFilter[size * (size - 1) + 1 + c];
											/*UF to RU*/destinationFilter[size * size + layerJump * (size - 2) + (size - 1) * size + size - 2 - c] = (originFilter[size * size + (size - 2) * 4 + 3 + c * layerJump] + numberOfLocations) % (numberOfLocations * 2);
											/*RU to UB*/destinationFilter[size * size + (size - 3 - c) * layerJump + 2 + (size - 2) * 3] = (originFilter[size * size + layerJump * (size - 2) + (size - 1) * size + size - 2 - c] + numberOfLocations) % (numberOfLocations * 2);
											/*UB to LU*/destinationFilter[size * (size - 1) + 1 + c] = originFilter[size * size + (size - 3 - c) * layerJump + 2 + (size - 2) * 3];

												}
										//corners
										/*RUB to LUB*/destinationFilter[size * (size - 1)] = originFilter[size * size + layerJump * (size - 2) + size * (size - 1)];
										/*LUB to LUF*/destinationFilter[size * (size - 1) + size - 1] = (originFilter[size * (size - 1)] + numberOfLocations) % (numberOfLocations * 3);
										/*LUF to RUF*/destinationFilter[size * size + layerJump * (size - 2) + size - 1 + size * (size - 1)] = originFilter[size * (size - 1) + size - 1];
										/*RUF to RUB*/destinationFilter[size * size + layerJump * (size - 2) + size * (size - 1)] = (originFilter[size * size + layerJump * (size - 2) + size - 1 + size * (size - 1)] + numberOfLocations * 2) % (numberOfLocations * 3);
											} else {
												offset = size + 1 + size * (planeLocation - 1);
												for (var c = 0; c < size - 2; c++) {//centers that are perp to the plane
										/*bac to lef*/destinationFilter[offset + c] = originFilter[size * size + size + c * layerJump + (planeLocation - 1) * 2];
										/*lef to frt*/destinationFilter[size * size + size + 1 + c * layerJump + (planeLocation - 1) * 2] = originFilter[offset + c];
										/*frt to rig*/destinationFilter[size * size + (size - 2) * layerJump + size + (size - 2 - c) + size * (planeLocation - 1)] = originFilter[size * size + size + 1 + c * layerJump + (planeLocation - 1) * 2];
										/*rig to bac*/destinationFilter[size * size + size + c * layerJump + (planeLocation - 1) * 2] = originFilter[size * size + (size - 2) * layerJump + size + (size - 2 - c) + size * (planeLocation - 1)];
												}
										//edges
										/*RB to LB*/destinationFilter[size + (planeLocation - 1) * size] = originFilter[size * size + (size - 2) * layerJump + size + (planeLocation - 1) * size];
										/*LB to LF*/destinationFilter[size + planeLocation * size - 1] = (originFilter[size + (planeLocation - 1) * size] + numberOfLocations) % (numberOfLocations * 2);
										/*LF to RF*/destinationFilter[size * size + (size - 2) * layerJump + size + planeLocation * size - 1] = originFilter[size + planeLocation * size - 1];
										/*RF to RB*/destinationFilter[size * size + (size - 2) * layerJump + size + (planeLocation - 1) * size] = (originFilter[size * size + (size - 2) * layerJump + size + planeLocation * size - 1] + numberOfLocations) % (numberOfLocations * 2);

											}

										}
										break;
									}
									case (2): {
										for (var l = 0; l < direction + 1; l++) {
											copyDestinationToOrigin();

											var layerJump = (size - 1) * 4;
											if (planeLocation == 0) {
												for (var c = 0; c < size - 2; c++) {//back side centers & edges
													//centers
													var offSet = size * size + size;
													for (var d = 0; d < size - 2; d++) {
														destinationFilter[offSet + d * layerJump + c * 2] = originFilter[offSet + c * layerJump + (size - 3 - d) * 2];
													}
											//edges
											/*UB to LB*/destinationFilter[size + size * c] = (originFilter[size * size + 3 * (size - 2) + 2 + c * layerJump] + numberOfLocations) % (numberOfLocations * 2);
											/*LB to DB*/destinationFilter[size * size + (size - 3 - c) * layerJump] = originFilter[size + size * c];
											/*DB to RB*/destinationFilter[size * size + (size - 2) * layerJump + (size - 2 - c) * size] = (originFilter[size * size + (size - 3 - c) * layerJump] + numberOfLocations) % (numberOfLocations * 2);
											/*RB to UB*/destinationFilter[size * size + 3 * (size - 2) + 2 + c * layerJump] = originFilter[size * size + (size - 2) * layerJump + (size - 2 - c) * size];

												}
										//corners
										/*LUB to LDB*/destinationFilter[0] = (originFilter[size * (size - 1)] + numberOfLocations * 2) % (numberOfLocations * 3);
										/*LDB to RDB*/destinationFilter[size * size + layerJump * (size - 2)] = originFilter[0];
										/*RDB to RUB*/destinationFilter[size * size + layerJump * (size - 2) + size * (size - 1)] = (originFilter[size * size + layerJump * (size - 2)] + numberOfLocations * 2) % (numberOfLocations * 3);
										/*RUB to LUB*/destinationFilter[size * (size - 1)] = (originFilter[size * size + layerJump * (size - 2) + size * (size - 1)] + numberOfLocations * 2) % (numberOfLocations * 3);


											} else if (planeLocation == size - 1) {
												for (var c = 0; c < size - 2; c++) {//front side centers & edges
													//centers
													var offSet = size * size + size + 1;
													for (var d = 0; d < size - 2; d++) {
														destinationFilter[offSet + d * layerJump + c * 2] = originFilter[offSet + c * layerJump + (size - 3 - d) * 2];
													}
											//edges
											/*UF to LF*/destinationFilter[size + size * c + size - 1] = (originFilter[size * size + 3 * (size - 2) + 2 + c * layerJump + size - 1] + numberOfLocations) % (numberOfLocations * 2);
											/*LF to DF*/destinationFilter[size * size + (size - 3 - c) * layerJump + size - 1] = originFilter[size + size * c + size - 1];
											/*DF to RF*/destinationFilter[size * size + (size - 2) * layerJump + (size - 2 - c) * size + size - 1] = (originFilter[size * size + (size - 3 - c) * layerJump + size - 1] + numberOfLocations) % (numberOfLocations * 2);
											/*RF to UF*/destinationFilter[size * size + 3 * (size - 2) + 2 + c * layerJump + size - 1] = originFilter[size * size + (size - 2) * layerJump + (size - 2 - c) * size + size - 1];

												}
										//corners
										/*LUF to LDF*/destinationFilter[size - 1] = (originFilter[size * size - 1] + numberOfLocations) % (numberOfLocations * 3);
										/*LDF to RDF*/destinationFilter[size * size + layerJump * (size - 2) + size - 1] = originFilter[size - 1];
										/*RDF to RUF*/destinationFilter[size * size + layerJump * (size - 2) + size * (size - 1) + size - 1] = (originFilter[size * size + layerJump * (size - 2) + size - 1] + numberOfLocations) % (numberOfLocations * 3);
										/*RUF to LUF*/destinationFilter[size * size - 1] = (originFilter[size * size + layerJump * (size - 2) + size * (size - 1) + size - 1] + numberOfLocations) % (numberOfLocations * 3);
											} else {
												offset = size + 1 + size * (planeLocation - 1);
												for (var c = 0; c < size - 2; c++) {//centers that are perp to the plane
											/*top to lef*/destinationFilter[planeLocation + (c + 1) * size] = originFilter[size * size + (size - 2) * 3 + 2 + planeLocation + c * layerJump];
											/*lef to dow*/destinationFilter[size * size + planeLocation + (size - 3 - c) * layerJump] = originFilter[planeLocation + (c + 1) * size];
											/*dow to rig*/destinationFilter[size * size + (size - 2) * layerJump + (size - 2 - c) * size + planeLocation] = originFilter[size * size + planeLocation + (size - 3 - c) * layerJump];
											/*rig to top*/destinationFilter[size * size + (size - 2) * 3 + 2 + planeLocation + c * layerJump] = originFilter[size * size + (size - 2) * layerJump + (size - 2 - c) * size + planeLocation];
												}
										//edges
										/*LU to LD*/destinationFilter[planeLocation] = (originFilter[size * (size - 1) + planeLocation] + numberOfLocations) % (numberOfLocations * 2);
										/*LD to RD*/destinationFilter[size * size + (size - 2) * layerJump + planeLocation] = originFilter[planeLocation];
										/*RD to RU*/destinationFilter[size * size + (size - 2) * layerJump + size * (size - 1) + planeLocation] = (originFilter[size * size + (size - 2) * layerJump + planeLocation] + numberOfLocations) % (numberOfLocations * 2);
										/*RU to LU*/destinationFilter[size * (size - 1) + planeLocation] = originFilter[size * size + (size - 2) * layerJump + size * (size - 1) + planeLocation];

											}

										}
										break;
									}
								}
							}
						}

						j++;
					}
					while (j < moveLength)
					builtFilters.push(destinationFilter);
				}
				return builtFilters;

			},
			CompressMoves(moves, cubeSize) {
				var layerCount = Algorithm.CountLayers(cubeSize);
				var maxValue = layerCount * 3;
				var POT = CubeData.CalculateBitLength(maxValue);
				var MovesArray = new Uint8Array(Math.ceil((POT * moves.length) / 8));
				for (var i = 0; i < moves.length / 2; i++) {
					CubeData.ChangeBinaryData(MovesArray, i * POT, moves[i * 2] + moves[i * 2 + 1] * layerCount, POT);

				}
				return MovesArray;
			}

		};

		var A2 = {//this is just here so that VS Code will show me suggestions for the Algorithm Object
			GetAllMoves(size) {
				var numberOfMoves = ((size % 2 === 1) ? (size - 1) * 3 : (size * 3)) * 3;
				var POT = CubeData.CalculateBitLength(numberOfMoves);
				var MovesArray = new Uint8Array(Math.ceil((POT * numberOfMoves) / 8));
				for (var i = 0; i < numberOfMoves; i++) {
					CubeData.ChangeBinaryData(MovesArray, i * POT, i, POT);
				}
				return MovesArray;
			},
			GetNumberOfMoves(size) {
				var numberOfMoves = ((size % 2 === 1) ? (size - 1) * 3 : (size * 3)) * 3;
				return numberOfMoves;
			}
		}
		var Controls = {
			GetMouseSelection: function () {//returns info about what the mouse is over in webgl
				var xRatio = Renderer.MapSize / window.innerWidth;
				var yRatio = Renderer.MapSize / window.innerHeight;
				var X = Math.floor(Controls.MouseX * xRatio);
				var Y = Math.floor((window.innerHeight - Controls.MouseY) * yRatio);
				var hasMessage = false;
				gl.bindFramebuffer(gl.FRAMEBUFFER, Renderer.MapBuffer);
				var info = new Uint8Array(4);

				gl.readPixels(X, Y, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, info)
				//op.innerHTML="Cube Number: "+info[0] + ", Sticker Number: "+(info[1]*256+info[2])+", Mouse Location: "+X+" , "+Y;
				if (info[0] != 255) {
					if (!Controls.MouseIsDown) {
						document.getElementById("cube_edit").style.cursor = "pointer";
					} else {
						document.getElementById("cube_edit").style.cursor = "move";
					}
					if (this.MouseClicked) {
						VCubeList[info[0]].changeSticker((info[1] * 256 + info[2]), selColor, true);
					}
					//highlight sides
					for (var i = 0; i < VCubeList[info[0]].cubies.length; i++) {
						var disCubie = false;
						for (var j = 0; j < VCubeList[info[0]].cubies[i].dataLink.length; j++) {

							if (VCubeList[info[0]].cubies[i].dataLink[j] === (info[1] * 256 + info[2])) {
								VCubeList[info[0]].cubies[i].highlightedSides[j] = true;
								if (VCubeList[info[0]].cubies[i].inError) {
									hasMessage = true;
									document.getElementById("cube_edit").title = VCubeList[info[0]].cubies[i].errorMessage;
								}
								disCubie = true;
							} else {
								VCubeList[info[0]].cubies[i].highlightedSides[j] = false;
							}
						}

						//VCubeList[info[0]].cubies[i].inError = disCubie;
					}
				} else {
					if (!Controls.MouseIsDown) {
						document.getElementById("cube_edit").style.cursor = "auto";
					}

				}
				if (!hasMessage)
					document.getElementById("cube_edit").title = "";
				return { Cube: info[0], Side: (info[1] * 256 + info[2]) };
			},
			MouseX: 0,
			MouseY: 0,
			OldMouseX: 0,
			OldMouseY: 0,
			MouseIsDown: false,
			MouseJustWentDown: false,
			MouseClicked: false,
			ClickTime: 200,//how long a the mouse must be down for it to no longer be a click
			ClickTimer: null,
			SelectedCube: -1,
			SetUp: function () {
				document.getElementById("cube_edit").addEventListener("mousemove", Controls.MouseMove);
				document.getElementById("cube_edit").addEventListener("mouseout", Controls.MouseUp);
				document.getElementById("cube_edit").addEventListener("mouseup", Controls.MouseUp);
				document.getElementById("cube_edit").addEventListener("mousedown", Controls.MouseDown);
				document.getElementById("cube_edit").addEventListener("touchmove", Controls.TouchMove);
				document.getElementById("cube_edit").addEventListener("touchcancel", Controls.TouchEnd);
				document.getElementById("cube_edit").addEventListener("touchend", Controls.TouchEnd);
				document.getElementById("cube_edit").addEventListener("touchstart", Controls.TouchStart);

			},
			MouseMove: function (e) {
				Controls.OldMouseX = Controls.MouseX;
				Controls.OldMouseY = Controls.MouseY;
				Controls.MouseX = e.clientX;
				Controls.MouseY = e.clientY;

			},
			MouseDown: function (e) {
				Controls.MouseIsDown = true;
				Controls.MouseJustWentDown = true;
				if (Controls.ClickTimer) {
					clearTimeout(Controls.ClickTimer);
				}
				Controls.ClickTimer = setTimeout(function () { Controls.MouseJustWentDown = false; Controls.ClickTimer = null; }, Controls.ClickTime);

			},
			MouseUp: function (e) {
				Controls.MouseIsDown = false;
				Controls.MouseJustWentDown = false;
				if (Controls.ClickTimer) {
					Controls.MouseClicked = true;
					requestAnimationFrame(function () {
						Controls.MouseClicked = false;
					});//make sure this is cleared on the next frame
					clearTimeout(Controls.ClickTimer);
					Controls.ClickTimer = null;
				}

				document.getElementById("cube_edit").style.cursor = "auto";

			},
			TouchMove: function (e) {
				e.preventDefault();
				Controls.OldMouseX = Controls.MouseX;
				Controls.OldMouseY = Controls.MouseY;
				Controls.MouseX = e.touches[0].clientX;
				Controls.MouseY = e.touches[0].clientY;

			},
			TouchStart: function (e) {

				e.preventDefault();
				Controls.MouseIsDown = true;
				Controls.MouseJustWentDown = true;
				if (Controls.ClickTimer) {
					clearTimeout(Controls.ClickTimer);
				}
				Controls.ClickTimer = setTimeout(function () { Controls.MouseJustWentDown = false; Controls.ClickTimer = null; }, Controls.ClickTime);

			},
			TouchEnd: function (e) {

				e.preventDefault();
				Controls.MouseIsDown = false;
				Controls.MouseJustWentDown = false;
				if (Controls.ClickTimer) {
					Controls.MouseClicked = true;
					requestAnimationFrame(function () {
						Controls.MouseClicked = false;
					});//make sure this is cleared on the next frame
					clearTimeout(Controls.ClickTimer);
					Controls.ClickTimer = null;
				}

				document.getElementById("cube_edit").style.cursor = "auto";

			},
			MoveCube: function () {
				if (Controls.SelectedCube != -1) {
					var dx = Controls.OldMouseX - Controls.MouseX;
					var dy = Controls.OldMouseY - Controls.MouseY;

					Controls.OldMouseX = Controls.MouseX;
					Controls.OldMouseY = Controls.MouseY;

					var rym = [Math.cos(dx * PR), 0, -Math.sin(dx * PR), 0,
						0, 1, 0, 0,
					Math.sin(dx * PR), 0, Math.cos(dx * PR), 0,
						0, 0, 0, 1];
					var rxm = [1, 0, 0, 0,
						0, Math.cos(dy * PR), Math.sin(dy * PR), 0,
						0, -Math.sin(dy * PR), Math.cos(dy * PR), 0,
						0, 0, 0, 1];
					var tMat = Renderer.Mat4Multiply(rym, rxm);
					VCubeList[Controls.SelectedCube].model_matrix = Renderer.Mat4Multiply(tMat, VCubeList[Controls.SelectedCube].model_matrix);
					document.getElementById("cube_edit").style.cursor = "move";
				}
			}

		};
		var ScoreMethods = {
			Surface: 0,
			Piece: 0
		};
		/**
		 * @Constructor
		 * @param {data} array
		*/
		function CubeNode(data, algorithm, score) {
			/**
				* A cube node for solving
				* @contructor
			*/
			this.data = data;
			this.algorithm = algorithm;
			this.score = score;
			//this.children = [];
			this.active = true;
			this.next = -1;
			this.last = -1;//the index of the next cubenode -1 is none.
		}
		var Solver = {
			Running: false,
			Cancel: false,//used to stop the async proccess.
			CubeSize: 3,
			MoveWeight: 1,//Calculation: size*size*5
			CubeData: null,
			CubeNodes: [],//All the Cube Nodes
			StartNode: -1,//the first node in the list as shifting an array gets crazy slow so we just change the first node on the list to move the new start cube
			//then each cube gets updated to know what cube is next in the list
			EndNode: -1,
			NodeListLength: 0,
			MaxNodes: 50000,
			IndexedNodes: [],//a list of nodes that are indexed to help sorting the list go faster. 100 values may be saved here [nodeNumber, vaule]
			//to help these will be in order with the final node always being in here to help get rid of the no go values right a way. No more looping 50,000 times per turn!
			DeadNodes: [],//a list of dead nodes
			Result: [],
			ScoreMax: 0,
			Status: 1,
			TryCount: 0,
			MaxTry: 100,
			StartTime: 0,
			EndTime: 0,
			//1 is running(if Running is true), 2 is failed(if running is false), 3 is success.
			/**
			* @param {vCube} vcube A cube to link to for failure and success(optional)
			*/
			SolveCube: function (data, format, size, success = this.Success, failure = this.Fail, vcube) {
				//testCube.data = new Uint8Array([141, 144, 36, 160, 85, 2, 100, 53, 8, 177, 52, 100, 102, 209, 13, 173, 210, 138, 85, 22, 0]);
				//TODO
				/*Solver.SolveCube(testCube.data,0,testCube.size,undefined,undefined,testCube)
				Data is input cube in the format specified.
				Success and Failure are what is supposed to happen if the function can solve the cube or cannot,
				success will take an input of (algorithm,startData) and failure will take an input of (errorCode,errorData,startData)
				where algorithm is the algorithm in an array of single number moves (so 5 refers to the move F') to solve the cube,
				startData is the original data used for the cube stored like so: {data,format}, errorCode is a number describing the error
				code 0 is a conversion error where the cube has invalid pieces, 1 is a duplicate error where cube has too many of a type of piece(a list of indexes of the duplicated pieces will be given),
				2 is a verified unsolveable error (cube cannot be solved), 3 is an unable to solve error (solution could not be found)
		
				ErrorData is the data associated with the error. For instance errorCode 0 will have this filled with the error data given by the CubeData.Convert method
		
				About error Codes 2 and 3:
				2 means that it is known that the cube cannot be solved and so a solution will not be attempted to solve it, this can be done by either using the human method of solving or some odd mathematics
				3 means that the cube should have a solution, however the program cannot find the solution
				*/

				/*
				Solve Plan:
					General Idea: In order to reduce the amount of branches created to find a solution to a cube, there will be two cubes created, Ones is the 
					start cube, the other is the solution cube. Both will work "inwards" to find a solution. 
		
					So the solve will start by trying all moves (1-5 in length) on the Solved side to see if the cube can be solved in 5 moves.
		
				Solve pipe line:
				Verification:
					Verify that the cube is valid (has the correct number of each piece), and has a solution
					After verification, the function will now execute async (weather in a WebWorker or with requestAnimationFrame())to allow for cube animation.
				Preparation:
					Make sure the correct algorithms and filters have been generated for the function to work.
				Solving Method:
					This will be based on a node based system.
					There will be a list, called Master List that will contain a list of 200 numbers, each refering to an item in the NodeList
					Each Node is a Cube with a score and its algorithm from the start state and child cube moves if any. 
					{Data:[data],Score:144,Algorithm:[],children[move,move],active:true} note Score is inversed for algorithm reasons. Note, score when checking 
					for where an item should be in the list is calculated by adding the Cube Score to the number of moves * the move weight, move weight is porportional to the cube size
					The Master list will be sorted by score with lowest on top.
					The algorithm will start by creating all 200 cube objects and saving them with the highest score possible for that size of cube and the data/alg empty.
					Then the start cube (converted into fast format) will be placed as the first node on the list. The goal is to reach score 0 (a solved cube). 
					Psudo Code:
						SortList();
						CheckTopItem
							If score is 0 exit and ouput algorithm
							else, try all moves on it and pick 2 moves (of the lowest score score if any) that lead to a lower score and add them as nodes to the list, pushing out the bottom most nodes
							If a score cannot be lowered in a move, kill the node and set the score to the max to drop it down to the bottom, also do checks if this cube exists in a prior state.
						
		
		
				
				*/
				//Verification
				var VerificationResults = Solver.CheckCube(data, format, size);
				if (!VerificationResults[0]) {//testFailed
					failure(VerificationResults[1], VerificationResults[2], data, vcube);
					Renderer.BackFlash = true;
					Renderer.ErrorSpeed = Math.abs(Renderer.ErrorSpeed);
					Renderer.ErrorTimer = 0;
					return;
				}
				for (var i = 0; i < vcube.cubies.length; i++) {
					vcube.cubies[i].inError = false;
				}
				var possible = this.CheckIfPossible(data, format, size);
				if (possible && !this.Running) {
					var fastData = CubeData.Convert(data, format, CubeDataType.Fast, size, false);
					this.CubeNodes = [];
					this.ScoreMax = (size - 2) * (size - 2) * 24 + (size - 2) * 24 * 3 + 48;

					this.DangerScoreLow = Solver.ScoreCube(Algorithm.TurnCube(generateSolvedCube(size, CubeDataType.Fast), 0, CubeDataType.Fast, size, [0, 0], 1, false, false), CubeDataType.Fast, size)[0];
					console.log(this.ScoreMax, this.DangerScoreLow);
					this.StartNode = 0;
					this.EndNode = 0;
					this.NodeListLength = 1;
					this.CubeNodes.push(new CubeNode(fastData, [], this.ScoreMax - this.ScoreCube(fastData, CubeDataType.Fast, size, ScoreMethods.Surface, [0])[0]));
					this.DeadNodes = [];
					this.MoveWeight = size * 3;
					this.CubeSize = size;
					this.Running = true;
					this.Status = 1;
					this.Cancel = false;
					this.CubeData = fastData;
					this.StartTime = performance.now();
					this.Count = 0;
					this.SolveControl();
				}

			},
			SolveControl: function () {
				for (var i = 0; i < Solver.MaxTry && Solver.Running; i++) {
					Solver.SolveRun();
				}
				var algArray = [];
				var algStr = "Top Alg: ";
				if (Solver.CubeNodes[Solver.StartNode]) {
					var alg = Solver.CubeNodes[Solver.StartNode].algorithm;
					var length = alg.length;
					var layerCount = Algorithm.CountLayers(Solver.CubeSize);
					for (var i = 0; i < length; i += 2) {
						algArray.push(alg[i] + alg[i + 1] * layerCount);
					}
					algStr += Algorithm.MovesToText(algArray, Solver.CubeSize, length / 2, false);
				} else {
					algStr += " No nodes found"
				}
				op.innerHTML = algStr//"Top Alg: "+(Solver.CubeNodes[Solver.StartNode] ? Solver.CubeNodes[Solver.StartNode].algorithm:"No nodes found");
				Solver.Count++;
				if (Solver.Running) {
					requestAnimationFrame(Solver.SolveControl);
				}
			},
			SolveRun: function () {
				if (!Solver.Cancel && Solver.Running) {
					if (Solver.StartNode == -1) {//If we have run out of nodes, then something really went wrong and we should stop right now
						Solver.Status = 2;
						Solver.Running = false;
						console.log("Ran out of nodes some how");
						return;
					}
					if (Solver.ScoreCube(Solver.CubeNodes[Solver.StartNode].data, CubeDataType.Fast, Solver.CubeSize)[0] === Solver.ScoreMax) {
						Solver.Status = 3;
						Solver.Running = false;
						Solver.Result = Solver.CubeNodes[Solver.StartNode] ? Solver.CubeNodes[Solver.StartNode].algorithm : "No nodes found";
						console.log("Success!");
						Solver.EndTime = performance.now();
						console.log("Itterations: " + Solver.Count);
						console.log("Duration: " + Math.round((Solver.EndTime - Solver.StartTime) / 1000))
						for (var i = 0; i < Solver.Result.length; i += 2) {
							testCube.addRotation(Solver.Result[i], Solver.Result[i + 1]);
						}
					} else {

						var cubes = [];
						var top5 = [];
						var cnode = Solver.NextNode();
						var startData = cnode.data;
						var currentScore = Solver.ScoreCube(cnode.data, CubeDataType.Fast, Solver.CubeSize)[0];
						var layersToDo = [];
						var allLayers = Algorithm.CountLayers(Solver.CubeSize);
						var algLength = cnode.algorithm.length / 2;
						var sAlg = cnode.algorithm;
						for (var i = 0; i < allLayers; i++) {
							if (Algorithm.CheckValidMove(i, Solver.CubeSize, algLength, cnode.algorithm)) {
								layersToDo.push(i);
							}
						}
						var lc = layersToDo.length;
						for (var i = 0; i < lc; i++) {
							var layer = layersToDo[i];
							//TurnCube:function(data,cube = 0,format,cubeSize,moves,moveCount=1,shouldEdit=true,compressed = true)
							var c1 = Algorithm.TurnCube(startData, 0, CubeDataType.Fast, Solver.CubeSize, [layer], 1, false, false);
							var c2 = Algorithm.TurnCube(startData, 0, CubeDataType.Fast, Solver.CubeSize, [layer + allLayers], 1, false, false);
							var c3 = Algorithm.TurnCube(startData, 0, CubeDataType.Fast, Solver.CubeSize, [layer + allLayers * 2], 1, false, false);
							var s1 = Solver.ScoreCube(c1, CubeDataType.Fast, Solver.CubeSize)[0];
							var s2 = Solver.ScoreCube(c2, CubeDataType.Fast, Solver.CubeSize)[0];
							var s3 = Solver.ScoreCube(c3, CubeDataType.Fast, Solver.CubeSize)[0];
							if (!(s1 > Solver.DangerScoreLow && s1 != Solver.ScoreMax))//not in the danger zone of close to but not finnished cubes
								cubes.push(c1, layer, 0, s1);
							if (!(s2 > Solver.DangerScoreLow && s2 != Solver.ScoreMax))
								cubes.push(c2, layer, 1, s2);
							if (!(s3 > Solver.DangerScoreLow && s3 != Solver.ScoreMax))
								cubes.push(c3, layer, 2, s3);
						}

						for (var i = 0; i < cubes.length; i += 4) {
							var low = Infinity;
							for (var j = 0; j < top5.length; j++) {
								if (cubes[top5[j] + 3] < low) {
									low = cubes[top5[j] + 3];
								}
							}

							if (cubes[i + 3] >= low || top5.length < 12) {
								top5.push(i);
								if (top5.length > 12) {
									var lowest = 0
									for (var j = 0; j < top5.length; j++) {
										if (cubes[top5[j] + 3] < cubes[top5[lowest] + 3]) {
											lowest = j;
										}
									}
									top5.splice(lowest, 1);
								}
							}
						}
						for (var i = 0; i < top5.length; i++) {
							var alg = sAlg.concat([cubes[top5[i] + 1], cubes[top5[i] + 2]]);
							var newNode = new CubeNode(cubes[top5[i]], alg, Solver.ScoreMax - cubes[top5[i] + 3] + alg.length / 2 * Solver.MoveWeight);
							Solver.InsertCubeNode(newNode);
						}
						///requestAnimationFrame(Solver.SolveRun);
					}
				} else {
					if (Solver.Cancel) {
						Solver.Running = false;
						Solver.Status = 2;
					} else {
						Solver.Status = 3;
					}
				}
			},
			ScoreCube: function (data, format, size, scoreMethod = ScoreMethods.Surface, cubes = [0]) {

				switch (scoreMethod) {
					case (ScoreMethods.Surface): {
						var scores = [];
						var cubeScore = 0;
						for (var i = 0; i < cubes.length; i++) {
							cubeScore = 0;
							cube = cubes[i];
							for (var j = 0; j < size * size; j++) {
								var x = j % size;
								var y = Math.floor(j / size);//note: orientation varies from side to side, which ever one makes the math easiest to calculate.
								var s0c = CubeData.PullSide(data, format, size, cube, x + y * size);//side 0 color, all sides are done at once
								var s1c = CubeData.PullSide(data, format, size, cube, x + y * (size * 4) + size * size);
								var s2c = CubeData.PullSide(data, format, size, cube, x * 2 + y * (size * 4) + size * size + size);
								var s3c = CubeData.PullSide(data, format, size, cube, x * 2 + y * (size * 4) + size * size + size + 1);
								var s4c = CubeData.PullSide(data, format, size, cube, x + y * (size * 4) + size * size + size * 3);
								var s5c = CubeData.PullSide(data, format, size, cube, x + y * size + size * size + size * (size * 4));
								if (x > 0) {
									if (s0c === CubeData.PullSide(data, format, size, cube, (x - 1) + y * size))
										cubeScore++;
									if (s1c === CubeData.PullSide(data, format, size, cube, (x - 1) + y * (size * 4) + size * size))
										cubeScore++;
									if (s2c === CubeData.PullSide(data, format, size, cube, (x - 1) * 2 + y * (size * 4) + size * size + size))
										cubeScore++;
									if (s3c === CubeData.PullSide(data, format, size, cube, (x - 1) * 2 + y * (size * 4) + size * size + size + 1))
										cubeScore++;
									if (s4c === CubeData.PullSide(data, format, size, cube, (x - 1) + y * (size * 4) + size * size + size * 3))
										cubeScore++;
									if (s5c === CubeData.PullSide(data, format, size, cube, (x - 1) + y * size + size * size + size * (size * 4)))
										cubeScore++;
								}

								if (x < size - 1) {
									if (s0c === CubeData.PullSide(data, format, size, cube, (x + 1) + y * size))
										cubeScore++;
									if (s1c === CubeData.PullSide(data, format, size, cube, (x + 1) + y * (size * 4) + size * size))
										cubeScore++;
									if (s2c === CubeData.PullSide(data, format, size, cube, (x + 1) * 2 + y * (size * 4) + size * size + size))
										cubeScore++;
									if (s3c === CubeData.PullSide(data, format, size, cube, (x + 1) * 2 + y * (size * 4) + size * size + size + 1))
										cubeScore++;
									if (s4c === CubeData.PullSide(data, format, size, cube, (x + 1) + y * (size * 4) + size * size + size * 3))
										cubeScore++;
									if (s5c === CubeData.PullSide(data, format, size, cube, (x + 1) + y * size + size * size + size * (size * 4)))
										cubeScore++;
								}

								if (y > 0) {
									if (s0c === CubeData.PullSide(data, format, size, cube, x + (y - 1) * size))
										cubeScore++;
									if (s1c === CubeData.PullSide(data, format, size, cube, x + (y - 1) * (size * 4) + size * size))
										cubeScore++;
									if (s2c === CubeData.PullSide(data, format, size, cube, x * 2 + (y - 1) * (size * 4) + size * size + size))
										cubeScore++;
									if (s3c === CubeData.PullSide(data, format, size, cube, x * 2 + (y - 1) * (size * 4) + size * size + size + 1))
										cubeScore++;
									if (s4c === CubeData.PullSide(data, format, size, cube, x + (y - 1) * (size * 4) + size * size + size * 3))
										cubeScore++;
									if (s5c === CubeData.PullSide(data, format, size, cube, x + (y - 1) * size + size * size + size * (size * 4)))
										cubeScore++;
								}
								if (y < size - 1) {
									if (s0c === CubeData.PullSide(data, format, size, cube, x + (y + 1) * size))
										cubeScore++;
									if (s1c === CubeData.PullSide(data, format, size, cube, x + (y + 1) * (size * 4) + size * size))
										cubeScore++;
									if (s2c === CubeData.PullSide(data, format, size, cube, x * 2 + (y + 1) * (size * 4) + size * size + size))
										cubeScore++;
									if (s3c === CubeData.PullSide(data, format, size, cube, x * 2 + (y + 1) * (size * 4) + size * size + size + 1))
										cubeScore++;
									if (s4c === CubeData.PullSide(data, format, size, cube, x + (y + 1) * (size * 4) + size * size + size * 3))
										cubeScore++;
									if (s5c === CubeData.PullSide(data, format, size, cube, x + (y + 1) * size + size * size + size * (size * 4)))
										cubeScore++;
								}


							}

							scores.push(cubeScore);
						}
						return scores;
						break;
					}
				}
			},
			Fail: function (errorCode, errorData, startData, cube) {
				switch (errorCode) {
					case (0): {
						if (cube) {
							for (var i = 0; i < cube.cubies.length; i++) {
								cube.cubies[i].inError = false;
							}
							for (var i = 0; i < errorData.length; i += 3) {
								cube.cubies[errorData[i + 1]].inError = true;
								cube.cubies[errorData[i + 1]].errorMessage = errorData[i];
							}
						}
						break;
					}
					case (1): {
						if (cube) {
							for (var i = 0; i < cube.cubies.length; i++) {
								cube.cubies[i].inError = false;
							}
							for (var i = 0; i < errorData.length; i++) {
								cube.cubies[errorData[i]].inError = true;
								cube.cubies[errorData[i]].errorMessage = "There is not the right amount of this kind of piece";
							}
						}
						break;
					}
				}
			},
			Success: function (alg, startData, cube) {

			},
			CheckCube: function (data, format, size) {
				//Checks to see if a cube is valid, has the right number of pieces and all valid pieces
				//if cube is good, returns [true], else it returns [false,errorCode,errorData]
				var testData = CubeData.Convert(data, format, CubeDataType.Piece, size, true);
				if (testData[1].length > 0) {
					// failure(0,testData[1],data,vcube);//Check for valid pieces
					return [false, 0, testData[1]];
				}
				testData = testData[0];
				var edges = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];//Check for correct number of pieces
				var centers = [0, 0, 0, 0, 0, 0];
				var corners = [0, 0, 0, 0, 0, 0, 0, 0];
				var edgeL = [[], [], [], [], [], [], [], [], [], [], [], []];//the location lists
				var centerL = [[], [], [], [], [], []];
				var cornerL = [[], [], [], [], [], [], [], []];
				var goalE = [size - 2, size - 2, size - 2, size - 2, size - 2, size - 2, size - 2, size - 2, size - 2, size - 2, size - 2, size - 2];
				var goalC = [(size - 2) * (size - 2), (size - 2) * (size - 2), (size - 2) * (size - 2), (size - 2) * (size - 2), (size - 2) * (size - 2), (size - 2) * (size - 2)];
				var goalN = [1, 1, 1, 1, 1, 1, 1, 1];
				for (var i = 0; i < size * size * 2 + (size - 2) * ((size + size - 2) * 2); i++) {
					var xyz = CubeData.GetPieceCoords(i, size);
					var sideCount = CubeData.CountSides(xyz[0], xyz[1], xyz[2], size);
					var pieceID = CubeData.PullInfo(testData, i, 5);

					if (sideCount == 1) {
						centers[pieceID % 6]++;
						centerL[pieceID % 6].push(i);
					} else if (sideCount == 2) {
						edges[pieceID % 12]++;
						edgeL[pieceID % 12].push(i);
					} else if (sideCount == 3) {
						corners[pieceID % 8]++;
						cornerL[pieceID % 8].push(i);
					}
				}
				var ge = Utility.ArrayMatch(edges, goalE, true);
				var gc = Utility.ArrayMatch(centers, goalC, true);
				var gn = Utility.ArrayMatch(corners, goalN, true);
				if (!ge[0] || !gc[0] || !gn[0]) {//any arrays not matched
					var errorInfo = [];
					if (!ge[0] && ge[1] == 1) {
						var l = ge[2].length;
						for (var i = 0; i < l; i++) {
							errorInfo = errorInfo.concat(edgeL[ge[2][i]]);
						}
					}
					if (!gc[0] && gc[1] == 1) {
						var l = gc[2].length;
						for (var i = 0; i < l; i++) {
							errorInfo = errorInfo.concat(centerL[gc[2][i]]);
						}
					}
					if (!gn[0] && gn[1] == 1) {
						var l = gn[2].length;
						for (var i = 0; i < l; i++) {
							errorInfo = errorInfo.concat(cornerL[gn[2][i]]);
						}
					}
					//failure(1,errorInfo,testData,vcube);
					return [false, 1, errorInfo];
				}
				return [true];
			},
			CheckIfPossible: function (data, format, size) {
				//Cube must be valid , AKA have all pieces and no invalid pieces for this to work(passed CheckCube test)
				//TODO
				//Swap test, must be an even number of swaps
				var swaps = 0;
				var testData = CubeData.Convert(data, format, CubeDataType.Piece, size, false);
				var checkList = [];//Tells us what pieces we have visited so far.
				for (var i = 0; i < (size * size * size) - (size - 2) * (size - 2) * (size - 2); i++)
					checkList.push(false);
				//Corner Swaps
				var cornerLocations = [0, size - 1, size * (size - 1), size * size - 1, size * size + (size - 2) * (size + size - 2) * 2, size * size + (size - 2) * (size + size - 2) * 2 + size - 1, size * size + (size - 2) * (size + size - 2) * 2 + size * (size - 1), size * size + (size - 2) * (size + size - 2) * 2 + size * size - 1]
				/*for(var i = 0;i<8;i++){
					 var currentPiece = CubeData.PullInfo(data,cornerLocations[i],5)%8;
					 if(!checkList[i]){
						if(currentPiece == i){
							CheckList[i]=true;//check this piece off the list as it is in its own spot
						}else{
							
						}
					 }
				}*/
				return true;
			},
			InsertCubeNode: function (node) {
				//debugger;
				var index = 0;
				var lastNodeId = -1;
				var currentNodeId = Solver.EndNode;
				var nextNodeId = -1;
				if (currentNodeId != -1) {
					lastNodeId = Solver.CubeNodes[currentNodeId].last;
				}
				var length = Solver.NodeListLength;
				var passed = false;
				var endmsg = "";
				//debugger;
				for (index = 0; index < length; index++) {
					if (Solver.CubeNodes[currentNodeId].score > node.score) {
						passed = true;
						if (lastNodeId == -1) {//we have hit the end of the list
							break;
						} else {
							nextNodeId = currentNodeId;
							currentNodeId = lastNodeId;
							lastNodeId = Solver.CubeNodes[currentNodeId].last;
						}
					} else {
						break;
					}
				}
				if (length < Solver.MaxNodes) {
					passed = true;
				}
				if (passed) {
					/*Solver.CubeNodes.splice(index,0,node);
					if(Solver.CubeNodes.length>Solver.MaxNodes){
						Solver.CubeNodes.pop();
					}*/
					var nodeToReplace = -1;
					if (Solver.NodeListLength >= Solver.MaxNodes) {//replace the end node
						nodeToReplace = Solver.EndNode;
						var endNode = Solver.CubeNodes[Solver.EndNode];
						var newEndNode = Solver.CubeNodes[endNode.last];
						endNode.active = false;
						newEndNode.next = -1;
						Solver.EndNode = endNode.last;
						if (nextNodeId == nodeToReplace) {
							nextNodeId = -1;
						}
						endmsg += "End Replace"
						//we don't take away from the total length as we will be replacing the old end node with a new node
					} else {
						if (Solver.DeadNodes.length > 0) {//replace a dead node
							nodeToReplace = Solver.DeadNodes.shift();
							Solver.NodeListLength++;
							endmsg += "Dead Replace"
						} else {
							if (Solver.CubeNodes.length < Solver.MaxNodes) {//create a new node
								Solver.CubeNodes.push(undefined);
								nodeToReplace = Solver.CubeNodes.length - 1;
								Solver.NodeListLength++;
								endmsg += "New node"
							} else {
								console.log("Well this is awkward, we ran out of nodes.");
							}
						}
					}

					if (nextNodeId == -1) {//we are creating a new end node;
						if (length > 0) {
							var endNode = Solver.CubeNodes[Solver.EndNode];
							endNode.next = nodeToReplace;
							node.last = Solver.EndNode;
							//default for next is -1 so we don't need to set it here
							Solver.EndNode = nodeToReplace;
							//?? delete Solver.CubeNodes[nodeToReplace];
							Solver.CubeNodes[nodeToReplace] = node;
							endmsg += "End attatch"
						} else {//Placing in only node in list
							Solver.CubeNodes[nodeToReplace] = node;
							Solver.EndNode = nodeToReplace;
							Solver.StartNode = nodeToReplace;
							endmsg += "Only attatch"
						}
					} else if (lastNodeId == -1) {// A start node
						var startNode = Solver.CubeNodes[Solver.StartNode];
						startNode.last = nodeToReplace;
						node.next = Solver.StartNode;
						//default for last is -1 so we don't need to set it here
						Solver.StartNode = nodeToReplace;
						//?? delete Solver.CubeNodes[nodeToReplace];
						Solver.CubeNodes[nodeToReplace] = node;
						endmsg += "Start attatch"
					} else {//we are inserting in the middle
						node.last = currentNodeId;
						node.next = nextNodeId;
						var currentNode = Solver.CubeNodes[currentNodeId];
						currentNode.next = nodeToReplace;
						var nextNode = Solver.CubeNodes[nextNodeId];
						nextNode.last = nodeToReplace;
						//?? delete Solver.CubeNodes[nodeToReplace];
						Solver.CubeNodes[nodeToReplace] = node;
						endmsg += "Mid attatch"
					}
					//var msg = (node.last)+" "+(nodeToReplace)+" "+(node.next)// + " Used "+ endmsg;
					//console.log(msg);



				} else {
					return false;
				}
			},
			NextNode: function () {
				if (Solver.StartNode > -1) {
					var startNode = Solver.CubeNodes[Solver.StartNode];
					var nextNodeID = startNode.next;
					var nextNode;
					Solver.DeadNodes.push(Solver.StartNode);
					if (nextNodeID != -1) {
						nextNode = Solver.CubeNodes[nextNodeID];
						startNode.active = false;
						nextNode.last = -1;
						Solver.StartNode = nextNodeID;
						Solver.NodeListLength--;
						return startNode;
					} else {//There is no more nodes!
						startNode.active = false;
						Solver.StartNode = -1;
						Solver.EndNode = -1;
						Solver.NodeListLength--;
						return startNode;
					}


				}
			}

		};
		var NodeList = {
			Sort: function (list) {

			},
			Insert: function (item, list) {
				//inserts an item into the list so that the list is still sorted, will drop bottom item if needed
			},
			Remove: function (item, list) {

			}

		}
		var Utility = {
			ArrayMatch: function (a1, a2, reportError = false) {
				//Error codes: 0 is mismatched length, 1 will provide a list of mismatched elements

				var errors = [];
				if (a1.length === a2.length) {
					var length = a1.length;
					for (var i = 0; i < length; i++) {
						if (a1[i] != a2[i]) {
							if (!reportError) {
								return false;
							} else {
								errors.push(i);
							}
						}
					}
					if (reportError) {
						if (errors.length === 0)
							return [true];
						else
							return [false, 1, errors];
					}
					return true;
				}
				if (reportError)
					return [false, 0];
				return false;
			}
		}
		var Study = {
			FileElement: document.createElement("Input"),
			Reader: new FileReader(),
			Data: null,
			Counter: 0,
			Setup: function () {
				FileElement.type = "file";
				FileElement.name = "Upload"
				document.getElementById("options").appendChild(FileElement);
				FileElement.onchange = function (e) {
					var file = this.files[0];
					Study.Reader.readAsArrayBuffer(file);
				}
				Reader.onload = function (e) {
					result = e.target.result;
					Data = new DataView(result);
					Study.Begin();
				}

			},
			Begin: function () {

			},
			Runer: function () {

			},
			Run: function () {

			}
			/*fReader.onload = function(e) {
		  result=e.target.result
		  data=new DataView(result)
		  try{
		  for(var a=0;a<data.byteLength;a++){
			var b=data.getUint8(a).toString(16).length == 2 ? data.getUint8(a).toString(16): "0" + data.getUint8(a).toString(16)
			lastBits.push(b);
			lastBits.splice(0,1);
			p.innerHTML+=" "+b.toUpperCase();
		check(["50","4b","01","02"],lastBits);
		  }
		  }catch(err){
			alert(err.stack)
		  }
		  alert("done" + "\n "+lastBits)
		  alert(search(["50","4b","03","04"],1,0,data.byteLength,1));
		}
		
		uploadButton.onchange = function(e) {
			var file = this.files[0];
			fReader.readAsArrayBuffer(file);
		}*/
		};

		function vCube(size = 3, format = 0, data = generateSolvedCube(size, format), scale = 5, style = CubieStyle.Plain, model_matrix = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], selectable = false) {
			this.size = size;//the number of cubies on the cube
			this.scale = scale;//the physical size of the cube
			this.data = data;
			this.format = format;
			this.style = style;
			this.selectable = selectable;//determines if this should render on color map for cube edits
			this.model_matrix = model_matrix;//defines the whole cubes model matrix for positioning and such.
			this.scale_matrix = [scale / size, 0, 0, 0,
				0, scale / size, 0, 0,
				0, 0, scale / size, 0,
				0, 0, 0, 1];
			this.cubies = [];
			this.retainStartData = false;//tells if the data it has should be updated or not when rotating or if it is just visual
			this.recording = false;//decides weither or not the rotation que should be emptied after each move.
			this.edit = true;
			this.timeControl = false;//tells wether or not the cube's animation is time controlled by something else such as a slider
			this.animationTime = 0;
			this.animationStart = 0;
			this.rotating = false;
			this.animationDuration = 100;
			this.currentDegrees = 0;
			this.targetDegrees = 0;
			this.rotationLocations = [0, 0, 0, 0];//cos -sin sin cos
			this.rotationMatrix = [];
			this.rotatingCubies = [];
			this.rotationQue = [];//saves the planned moves and previous moves if recording is set to true
			this.quePosition = 0;//used when recording as the que is not emptied then.
			this.idColor = VCubeList.length;//for identifying its self when clicked on for rotations and changes
			//Id color informatiton for cubies R: cube in VCubelist, G * 255 + B = sticker on cube.

			VCubeList.push(this);
			this.changeScale = function (scale) {
				this.scale = scale;
				this.scale_matrix = [scale / this.size, 0, 0, 0,
					0, scale / this.size, 0, 0,
					0, 0, scale / this.size, 0,
					0, 0, 0, 1];
			};
			this.changeSticker = function (sticker, id, override = false) {
				//sticker is a number that identifies which sticker is being changed
				//id is what color to change the sticker to
				//override allows the function to automatically change the format of the cube to surface type if possible to change a single sticker
				//returns true or false to tell if it was a success or not
				if (this.format == CubeDataType.Surface && !this.recording && this.edit) {
					CubeData.Change(this.data, CubeDataType.Surface, 0, sticker, this.size, id);
					this.updateColors();
				} else if (this.format == CubeDataType.Piece && override && !this.recording && this.edit) {
					this.data = CubeData.Convert(this.data, CubeDataType.Piece, CubeDataType.Surface, this.size, false);
					this.format = CubeDataType.Surface;
					return this.changeSticker(sticker, id);
				} else {
					if (this.format == CubeDataType.Piece && !override) {
						throw "Cannot change data type of cube without override enabled!";
					} else if (this.format == CubeDataType.Compact) {
						throw "Cannot change data type of cube from compact data!";
					} else if (!(!this.recording && this.edit)) {
						throw "Cannot edit data, cube does not have editing enabled!";
					}
					else {
						throw "An error occured!";
					}
				}
			};
			this.updateColors = function () {//updates the colors on cubies to match that of the data, resets the cubies position as a result, should only be used on edit cubes or cubes that update the data as they go along.
				for (var i = 0; i < this.cubies.length; i++) {
					var c = this.cubies[i];
					var newColors = [0, 0, 0];
					for (var j = 0; j < c.type + 1; j++) {
						newColors[j] = CubeData.PullSide(this.data, this.format, this.size, 0, c.dataLink[j]);
					}
					c.home = 0;
					Renderer.UpdateModel(c, 0, newColors);
				}
			};
			this.resetCubies = function () {//resets the cubies back to their original positions, good for redoing stuff I guess
				if (!this.recording && !this.retainStartData) {
					this.updateColors();
				} else {
					this.quePosition = 0;
				}
				var baseMatrix = [
					1, 0, 0, -this.size / 2 + 0.5,
					0, 1, 0, -this.size / 2 + 0.5,
					0, 0, 1, -this.size / 2 + 0.5,
					0, 0, 0, 1
				];//cube space (until it is scaled based on the scale) is represented as a size by size by size area with 0,0,0 in the middle, pieces will start in their LDB location and then rotated to the correct location
				//depending on how their home is set up, a different  rotation may be used.
				//values can be pre computed
				var rym = [
					0, 0, -1, 0,
					0, 1, 0, 0,
					1, 0, 0, 0,
					0, 0, 0, 1];//rotation to back
				var rym3 = [
					0, 0, 1, 0,
					0, 1, 0, 0,
					-1, 0, 0, 0,
					0, 0, 0, 1];//rotation to front
				var rym2 = [
					-1, 0, 0, 0,
					0, 1, 0, 0,
					0, 0, -1, 0,
					0, 0, 0, 1];//rotation to right

				var rzm = [
					0, -1, 0, 0,
					1, 0, 0, 0,
					0, 0, 1, 0,
					0, 0, 0, 1];//rotation to top
				var rzm3 = [
					0, 1, 0, 0,
					-1, 0, 0, 0,
					0, 0, 1, 0,
					0, 0, 0, 1];//rotation to bottom
				var rxm = [1, 0, 0, 0,
					0, 0, 1, 0,
					0, -1, 0, 0,
					0, 0, 0, 1];
				var rxm2 = [1, 0, 0, 0,
					0, -1, 0, 0,
					0, 0, -1, 0,
					0, 0, 0, 1];
				var rxm3 = [1, 0, 0, 0,
					0, 0, -1, 0,
					0, 1, 0, 0,
					0, 0, 0, 1];
				var scaleZIndex = 11;
				var scaleYIndex = 7;
				var tz = [
					1, 0, 0, 0,
					0, 1, 0, 0,
					0, 0, 1, 1,
					0, 0, 0, 1];
				var ty = [
					1, 0, 0, 0,
					0, 1, 0, 1,
					0, 0, 1, 0,
					0, 0, 0, 1];
				for (var i = 0; i < this.cubies.length; i++) {
					var info = CubeData.GetRenderCoords(this.size, i);
					var modMat = [
						1, 0, 0, 0,
						0, 1, 0, 0,
						0, 0, 1, 0,
						0, 0, 0, 1];
					tz[scaleZIndex] = info[1].x;
					ty[scaleYIndex] = info[1].y;
					if (info[0] === 1) {
						modMat = rzm.slice(0);
					} else if (info[0] === 2) {
						modMat = rym.slice(0);
					} else if (info[0] === 3) {
						modMat = rym3.slice(0);
					} else if (info[0] === 4) {
						modMat = rzm3.slice(0);
					} else if (info[0] === 5) {
						modMat = rym2.slice(0);
					}
					modMat = Renderer.Mat4Multiply(modMat, tz);
					modMat = Renderer.Mat4Multiply(modMat, ty);
					modMat = Renderer.Mat4Multiply(modMat, baseMatrix);
					if (info[2] === 1) {
						modMat = Renderer.Mat4Multiply(modMat, rxm);
					} else if (info[2] === 2) {
						modMat = Renderer.Mat4Multiply(modMat, rxm2);
					} else if (info[2] === 3) {
						modMat = Renderer.Mat4Multiply(modMat, rxm3);
					}
					this.cubies[i].model[3] = modMat;

				}


			};
			this.addRotation = function (layer, direction) {//adds a rotation to the que

				var layerCount = Algorithm.CountLayers(this.size);
				this.rotationQue.push(layer + direction * layerCount);
			};
			this.rotate = function (move) {//only used to actualy rotate the data by the vCube itself, not meant to be accessed else where.
				var totalMoves = Algorithm.CountLayers(this.size);
				var POT = CubeData.CalculateBitLength(totalMoves * 3);
				var savedArray = new Uint8Array(Math.ceil(POT / 8));
				CubeData.ChangeBinaryData(savedArray, 0, move, POT);
				Algorithm.TurnCube(this.data, 0, this.format, this.size, savedArray);

				//console.log(Solver.ScoreCube(this.data,this.format,this.size));//STUDY DEBUG
			};
			this.rotateCubies = function (move) {//updates the cubies position in the cubie list for proper coordinate selecting for animations and cube editing

				//turns can be simplified into pieces that are swapped and transformed, using a lot of the cubeData utilities made previously, this should not be a hard task.
				var ftu = -1;//filter to use
				for (var i = 0; i < Algorithm.SavedFilters.length; i += 4) {//check for the filters we need for the moves we are doing, if they are not already built, build them.
					if (Algorithm.SavedFilters[i] == this.size && Algorithm.SavedFilters[i + 1] == CubeDataType.Piece && Algorithm.SavedFilters[i + 2 == 1]) {
						ftu = i + 3;
						break;
					}
				}
				if (ftu == -1) {
					Algorithm.SavedFilters.push(this.size, CubeDataType.Piece, 1, Algorithm.BuildFilters(this.size, CubeDataType.Piece));
					ftu = Algorithm.SavedFilters.length - 1;
				}
				var destinationList;


				destinationList = this.cubies.slice(0);
				var filterLength = Algorithm.SavedFilters[ftu][move].length;
				var spareObject;
				var LocationCount = this.size * this.size * this.size - (this.size - 2) * (this.size - 2) * (this.size - 2);

				for (var j = 0; j < filterLength; j++) {
					var originLocation = Algorithm.SavedFilters[ftu][move][j];
					originLocation %= LocationCount;
					destinationList[j] = this.cubies[originLocation];
					var xyz = CubeData.GetPieceCoords(j, this.size);
					var x = xyz[0];
					var y = xyz[1];
					var z = xyz[2];
					var dl = CubeData.GetSides(x, y, z, this.size);
					var cubieIdData = [[this.idColor / 256, 0, 0], [this.idColor / 256, 0, 0], [this.idColor / 256, 0, 0]];
					for (var i = 0; i < dl.length; i++) {
						cubieIdData[i][1] = Math.floor(dl[i] / 256) / 255;
						cubieIdData[i][2] = (dl[i] % 256) / 255;
					}
					var cw = true;
					if ((x == 0 && y == 0 && z != 0) || (x == 0 && y != 0 && z != 0) || (x != 0 && y != 0 && z == 0) || (x != 0 && y == 0 && z == 0)) {//finds the pieces where the data is not already clockwise when given through color[]
						cw = false;
					}
					destinationList[j].dataLink = dl;
					if (!cw && CubeData.CountSides(x, y, z, this.size) > 2) {
						destinationList[j].dataLink = [dl[0], dl[2], dl[1]];
						Renderer.UpdateModel(destinationList[j], 1, [cubieIdData[0], cubieIdData[2], cubieIdData[1]]);
					}
					else
						Renderer.UpdateModel(destinationList[j], 1, cubieIdData);
				}
				this.cubies = destinationList.slice(0);


			}
			this.render = function (shouldAnimate) {
				//shouldAnimate decides if the cube should progress its animation or not.


				if (!this.timeControl && shouldAnimate) {//Is the cube just being moved but not controlled by an external source?
					if (this.rotating) {
						this.animationTime++;
						if (this.animationTime >= this.animationDuration) {//Is the animation done?
							this.animationTime = 0;

							/*
							var rym=[Math.cos(degy*pr),0,-Math.sin(degy*pr),0,
									 0,1,0,0,
									 Math.sin(degy*pr),0,Math.cos(degy*pr),0,
									 0,0,0,1];
							var rxm=[1,0,0,0,
									 0,Math.cos(degx*pr),Math.sin(degx*pr),0,
									 0,-Math.sin(degx*pr),Math.cos(degx*pr),0,
									 0,0,0,1];
							var rzm=[Math.cos(degz*pr),-Math.sin(degz*pr),0,0,
									 Math.sin(degz*pr),Math.cos(degz*pr),0,0,
									 0,0,1,0,
									 0,0,0,1];
							*/
							this.rotationMatrix[this.rotationLocations[0]] = Math.round(Math.cos(PR * this.targetDegrees));//update the rotation matrix to reflect the goal position
							this.rotationMatrix[this.rotationLocations[1]] = Math.round(-Math.sin(PR * this.targetDegrees));
							this.rotationMatrix[this.rotationLocations[2]] = Math.round(Math.sin(PR * this.targetDegrees));
							this.rotationMatrix[this.rotationLocations[3]] = Math.round(Math.cos(PR * this.targetDegrees));
							for (var i = 0; i < this.rotatingCubies.length; i++) {
								//Add the rotation matrix applied through the temp matrix on the cubies to the cubies own model matrix and reset the temp matrix
								this.cubies[this.rotatingCubies[i]].model[3] = Renderer.Mat4Multiply(this.rotationMatrix, this.cubies[this.rotatingCubies[i]].model[3]);
								this.cubies[this.rotatingCubies[i]].model[6] = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];

							}

							this.rotatingCubies = [];
							this.rotateCubies(this.rotationQue[0]);
							this.rotate(this.rotationQue[0]);
							if (!this.recording) {
								this.rotationQue.splice(0, 1);
							}
							if (this.recording || this.retainStartData && this.rotationQue.length > this.quePosition + 1) {
								//Are we recording and is there more information in the que? if so don't damage the start data but start animating the next rotation
								this.quePosition++;

								var layer;
								var direction;
								var isOdd = (this.size % 2 == 1);
								var plane = 0;//0 is along z value, 1 is y, 2 is x
								var planeLocation = 0;//tells which slice of cube you are on.
								layer = this.rotationQue[this.quePosition];
								direction = Math.floor(layer / Algorithm.CountLayers(this.size));//add one to this to see how many times a rotation should be done
								layer %= Algorithm.CountLayers(this.size);

								if (isOdd) {
									plane = Math.floor(layer / (this.size - 1));
									planeLocation = layer % (this.size - 1);
									if (planeLocation + 1 > this.size / 2) {
										planeLocation++;
									}
								}
								else {
									plane = Math.floor(layer / this.size);
									planeLocation = layer % this.size;
								}
								var cl = this.cubies.length;
								for (var i = 0; i < cl; i++) {
									var location = CubeData.GetPieceCoords(i, this.size);//BUG FIX this will not work after the first rotaion right now
									if (location[plane] == planeLocation) {
										this.rotatingCubies.push(i);
									}
								}
								this.rotationMatrix = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
								switch (direction) {
									case 0: this.targetDegrees = 90;
										break;
									case 1: this.targetDegrees = 180;
										break;
									case 2: this.targetDegrees = -90;
										break;

								}
								switch (plane) {
									case 0: this.rotationLocations = [5, 6, 9, 10];
										break;
									case 1: this.rotationLocations = [0, 2, 8, 10];
										this.targetDegrees *= -1;
										break;
									case 2: this.rotationLocations = [0, 1, 4, 5];
										break;

								}
							} else if (this.rotationQue.length > 0) {
								//if we are not recoriding but still have some info in the que, animate and update the data as well for the next rotaion in que.
								var layer;
								var direction;
								var isOdd = (this.size % 2 == 1);
								var plane = 0;//0 is along z value, 1 is y, 2 is x
								var planeLocation = 0;//tells which slice of cube you are on.
								layer = this.rotationQue[0];
								//this.rotate(layer);
								direction = Math.floor(layer / Algorithm.CountLayers(this.size));//add one to this to see how many times a rotation should be done
								layer %= Algorithm.CountLayers(this.size);

								if (isOdd) {
									plane = Math.floor(layer / (this.size - 1));
									planeLocation = layer % (this.size - 1);
									if (planeLocation + 1 > this.size / 2) {
										planeLocation++;
									}
								}
								else {
									plane = Math.floor(layer / this.size);
									planeLocation = layer % this.size;
								}
								var cl = this.cubies.length;
								for (var i = 0; i < cl; i++) {
									var location = CubeData.GetPieceCoords(i, this.size);//BUG FIX NOW
									if (location[plane] == planeLocation) {
										this.rotatingCubies.push(i);
									}
								}
								this.rotationMatrix = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
								switch (direction) {
									case 0: this.targetDegrees = 90;
										break;
									case 1: this.targetDegrees = 180;
										break;
									case 2: this.targetDegrees = -90;
										break;

								}
								switch (plane) {
									case 0: this.rotationLocations = [5, 6, 9, 10];
										break;
									case 1: this.rotationLocations = [0, 2, 8, 10];
										this.targetDegrees *= -1;//for some reason this plane rotates differently causing a desync between visual and internal data
										break;
									case 2: this.rotationLocations = [0, 1, 4, 5];
										break;

								}
							} else {
								this.rotating = false;
							}
							this.resetCubies();
						} else {//if the animation is on going, update the rotation matrix for all the cubies that are affected
							var per = this.animationTime / this.animationDuration;
							this.currentDegrees = per * per * this.targetDegrees;
							this.rotationMatrix[this.rotationLocations[0]] = Math.cos(PR * this.currentDegrees);
							this.rotationMatrix[this.rotationLocations[1]] = -Math.sin(PR * this.currentDegrees);
							this.rotationMatrix[this.rotationLocations[2]] = Math.sin(PR * this.currentDegrees);
							this.rotationMatrix[this.rotationLocations[3]] = Math.cos(PR * this.currentDegrees);
							for (var i = 0; i < this.rotatingCubies.length; i++) {
								this.cubies[this.rotatingCubies[i]].model[6] = this.rotationMatrix;
							}
						}

					} else if (this.rotationQue.length > 0) {//if we are not rotating right now, should we be?
						this.rotating = true;
						var layer;
						var direction;
						var isOdd = (this.size % 2 == 1);
						var plane = 0;//0 is along z value, 1 is y, 2 is x
						var planeLocation = 0;//tells which slice of cube you are on.
						if (this.recording || this.retainStartData) {
							layer = this.rotationQue[this.quePosition];
						} else {
							layer = this.rotationQue[0];
							//this.rotate(layer);
						}
						direction = Math.floor(layer / Algorithm.CountLayers(this.size));//add one to this to see how many times a rotation should be done
						layer %= Algorithm.CountLayers(this.size);

						if (isOdd) {
							plane = Math.floor(layer / (this.size - 1));
							planeLocation = layer % (this.size - 1);
							if (planeLocation + 1 > this.size / 2) {
								planeLocation++;
							}
						} else {
							plane = Math.floor(layer / this.size);
							planeLocation = layer % this.size;
						}
						var cl = this.cubies.length;
						this.rotatingCubies = [];
						for (var i = 0; i < cl; i++) {
							var location = CubeData.GetPieceCoords(i, this.size);//BUG FIX this will not work after the first rotaion right now
							if (location[plane] == planeLocation) {
								this.rotatingCubies.push(i);
							}
						}
						this.rotationMatrix = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
						switch (direction) {
							case 0: this.targetDegrees = 90;
								break;
							case 1: this.targetDegrees = 180;
								break;
							case 2: this.targetDegrees = -90;
								break;

						}
						switch (plane) {
							case 0: this.rotationLocations = [5, 6, 9, 10];
								break;
							case 1: this.rotationLocations = [0, 2, 8, 10];
								this.targetDegrees *= -1;
								break;
							case 2: this.rotationLocations = [0, 1, 4, 5];
								break;

						}
					}
				}
				Renderer.RenderCubies(this.cubies, this.selectable, Renderer.Mat4Multiply(this.scale_matrix, this.model_matrix));
			};
			//add cubies and load colors from the data.
			for (var x = 0; x < this.size; x++) {
				for (var y = 0; y < this.size; y++) {
					for (var z = 0; z < this.size; z++) {
						var count = CubeData.CountSides(x, y, z, this.size);
						if (count > 0) {
							var sides = CubeData.GetSides(x, y, z, this.size);
							var cubieData = [0, 0, 0];
							var cubieIdData = [[this.idColor / 256, 0, 0], [this.idColor / 256, 0, 0], [this.idColor / 256, 0, 0]];
							var cubieDataLink = sides.slice(0);
							var cw = true;
							//finds the pieces where the data is not already clockwise when given through color[]
							if ((x == 0 && y == 0 && z != 0) || (x == 0 && y != 0 && z != 0) || (x != 0 && y != 0 && z == 0) || (x != 0 && y == 0 && z == 0)) {
								cw = false;
							}
							for (var i = 0; i < sides.length; i++) {
								cubieData[i] = CubeData.PullSide(this.data, this.format, this.size, 0, sides[i]);
								cubieIdData[i][1] = Math.floor(sides[i] / 256) / 255;
								cubieIdData[i][2] = (sides[i] % 256) / 255;
							}
							if (!cw && count > 2) {
								this.cubies.push(new Cubie(count - 1, this.style, [cubieData[0], cubieData[2], cubieData[1]]));
								Renderer.UpdateModel(this.cubies[this.cubies.length - 1], 1, [cubieIdData[0], cubieIdData[2], cubieIdData[1]]);
								this.cubies[this.cubies.length - 1].dataLink = [cubieDataLink[0], cubieDataLink[2], cubieDataLink[1]]
							} else {
								this.cubies.push(new Cubie(count - 1, this.style, cubieData));
								Renderer.UpdateModel(this.cubies[this.cubies.length - 1], 1, cubieIdData);
								this.cubies[this.cubies.length - 1].dataLink = cubieDataLink;
							}
						}
					}
				}
			}
			this.resetCubies();


		}
		var degx = 0;
		var degy = 0;
		var degz = 0;
		var trans = -10;
		var op = document.getElementById("debugOP");
		var debugVBuffer = null;
		var debugEBuffer = null;
		var selColor = 0;

		var VCubeList = [];

		function update() {
			// ??????
			// I have no memory as to why this is here
			requestAnimationFrame(update);
		}
		var testCube;
		function start() {
			Renderer.SetUp();
			Controls.SetUp();
			Renderer.SetUpCamera();
			Renderer.Clear();
			testCube = new vCube(3, CubeDataType.Surface, generateSolvedCube(3, CubeDataType.Surface), undefined, undefined, undefined, true);
			testCube.render();
			draw();
		}
		function draw() {
			Renderer.ErrorAnimationColor = [Renderer.ErrorTimer / 1000 * Renderer.ErrorColor[0], Renderer.ErrorTimer / 1000 * Renderer.ErrorColor[1], Renderer.ErrorTimer / 1000 * Renderer.ErrorColor[2]];
			Renderer.ErrorTimer += Renderer.ErrorSpeed;
			if (Renderer.ErrorTimer >= 1000) {
				Renderer.ErrorSpeed = -Math.abs(Renderer.ErrorSpeed);
			}
			if (Renderer.ErrorTimer <= 0) {
				Renderer.ErrorSpeed = Math.abs(Renderer.ErrorSpeed);
				Renderer.BackFlash = false;
			}
			Renderer.SetUpCamera();
			Renderer.SetUpMain(true);
			testCube.render(true);
			Renderer.SetUpMain();
			/*
			gl.useProgram(Renderer.DebugProgram);//debug for drawing the color map to the screen
							
			gl.uniform1i(Renderer.DebugUniforms.main_texture,2);
						
			gl.bindBuffer(gl.ARRAY_BUFFER,debugVBuffer);
			gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,debugEBuffer);
						
			Renderer.setAts(2);
							
			gl.drawElements(gl.TRIANGLES,6,gl.UNSIGNED_SHORT,0);
			//*/
			var info = Controls.GetMouseSelection();
			if (Controls.MouseJustWentDown && info.Cube != 255) {
				Controls.SelectedCube = info.Cube;
			}
			if (Controls.MouseIsDown && !Controls.MouseJustWentDown && Controls.selectedCube != -1) {
				Controls.MoveCube();
			} else if (!Controls.MouseIsDown) {
				Controls.SelectedCube = -1;
			}

			requestAnimationFrame(draw);
		}


		/*
		Notes and TO DO
		Allow vCubes to have a time seeker/be controlled by a slider
		Create turn filter for piece type data
			Add this feature to rearrange cubies in side of the vCube array to allow for PROPER coordinate selecting
		Allow vCubes to be edited (surface type only) (Maybe force all vCubes to have a surface data type for memory reasons?)
		Create Settings object - object that handels all settings and setting operations (such as visual, language, and various other items)
		Create Solver object - object that handels all solving operations
			Add Solver.Score method that will score the cubes based on different criteria to give a total
			Add Solver.solve method, solves the cube. (Possibly using A* algorithm?)
			Add Solver.CheckIfPossible method.
			Add Solver.CheckIfValid method.
		Work on mobile function
		Optimize algorithm code
		Run tests
		*/
		//apply super flip to 3by3
		/*nray = [3,2,
		1,1,
		5,2,
		4,0,
		1,2,
		4,1,
		1,2,
		3,1,
		0,0,
		4,1,
		1,2,
		3,0,
		2,2,
		1,1,
		5,2,
		1,0,
		0,0,
		4,1,
		3,1,
		5,1];
		for(var i = 0;i<nray.length;i+=2){testCube.addRotation(nray[i],nray[i+1]);}*/
		var allCubes;
		function DOSTUFF() {
			allCubes = CubeData.Create(CubeDataType.Surface, 3, 32076);
			var solvedCube = generateSolvedCube(3, CubeDataType.Surface);
			for (var i = 0; i < 32076; i++) {//428166
				//cubeSize,AlgLength,AlgNumber,compressed
				var workingCube = CubeData.Copy(solvedCube);
				var algorithm = Algorithm.GetAlgorithm(3, 4, i, true);
				cList.push(i);
				//data,cube = 0,format,cubeSize,moves,moveCount=1,shouldEdit=true
				Algorithm.TurnCube(workingCube, 0, CubeDataType.Surface, 3, algorithm, 4, true);
				CubeData.PasteCube(allCubes, CubeDataType.Surface, workingCube, i, 3);
				if (i % 100 == 0)
					console.log(i);
			}
		}
		var sameCount = 0;
		var sectionCount = 0;
		var pairList = [];
		var cList = [];
		var i1 = 0;
		var i2 = 0;
		//I think this code looks for matching cube pairs, but I am not sure...
		function DOSTUFFPART2() {
			for (var i = 0; i < 32076; i++) {//428166
				for (var j = i + 1; j < 32076; j++) {//428166
					if (i != j) {
						sectionCount = 0;
						for (var k = 0; k < 6; k++) {
							i1 = CubeData.PullInfo(allCubes, i * 6 + k, 27);
							i2 = CubeData.PullInfo(allCubes, j * 6 + k, 27);
							if (i1 === i2) {
								sectionCount++;
							} else {
								break;
							}
						}
						if (sectionCount == 6) {
							sameCount++;
							pairList.push([i, j]);
							break;
						}

					}

				}
				console.log(i);

			}
		}

		var AllxMoveAlgs = [];
		var XmoveScores = [];//{CubeSize:0,AlgLength:0,Scores:[[0,0],[1,100]]}

		function ScoreAllXMoveCubes(cubeSize = 3, xNumber = 3) {
			//Search to see if the Algorithm was cached yet, if not request to start the run for it.
			var isCreated = false;
			var indexNumber = 0;
			var scores = [];
			for (var i = 0; i < Algorithm.TotalAlgorithms.length; i += 3) {
				if (Algorithm.TotalAlgorithms[i] == cubeSize && Algorithm.TotalAlgorithms[i + 1] == xNumber) {
					isCreated = true;
					indexNumber = i;
					break;
				}
			}
			if (!isCreated) {
				console.log(xNumber + " Move Algorithms for a " + cubeSize + " sized cube have not been created, A request for it was made, please what for it to finish");
				Algorithm.AlgIndex(cubeSize, xNumber);
				return;
			}

			AllxMoveAlgs = [];
			numberOfAlgs = 0;
			for (var i = 0; i < Algorithm.TotalAlgorithms[indexNumber + 2]; i++) {
				var newAlg = Algorithm.GetAlgorithm(cubeSize, xNumber, i, false);
				for (var j = 0; j < newAlg.length; j++) {
					AllxMoveAlgs.push(newAlg[j]);
				}
			}

			var ftu = -1;//filter to use
			for (var i = 0; i < Algorithm.SavedFilters.length; i += 4) {//check for the filters we need for the moves we are doing, if they are not already built, build them.
				if (Algorithm.SavedFilters[i] == cubeSize && Algorithm.SavedFilters[i + 1] == CubeDataType.Surface && Algorithm.SavedFilters[i + 2] == xNumber) {
					ftu = i + 3;
					break;
				}
			}
			if (ftu == -1) {
				Algorithm.SavedFilters.push(cubeSize, CubeDataType.Surface, xNumber, Algorithm.BuildFilters(cubeSize, CubeDataType.Surface, Algorithm.CompressMoves(AllxMoveAlgs, cubeSize), Algorithm.TotalAlgorithms[indexNumber + 2] * xNumber, xNumber));
				ftu = Algorithm.SavedFilters.length - 1;
			}

			for (var i = 0; i < Algorithm.TotalAlgorithms[indexNumber + 2]; i++) {
				myCube = generateSolvedCube(cubeSize, CubeDataType.Surface);
				Algorithm.TurnCube(myCube, 0, CubeDataType.Surface, cubeSize, Algorithm.GetAlgorithm(cubeSize, xNumber, i, true), 1, true, true, xNumber);
				aScore = Solver.ScoreCube(myCube, CubeDataType.Surface, cubeSize);
				scoreFound = false;

				for (var j = 0; j < scores.length; j++) {
					if (scores[j][0] == aScore[0]) {
						scores[j][1]++;
						scoreFound = true;
					}
				}
				if (!scoreFound) {
					scores.push([aScore[0], 1])
				}
			}
			XmoveScores.push({ "CubeSize": cubeSize, "AlgLength": xNumber, "Scores": scores })


		}


	</script>
</body>

</html>